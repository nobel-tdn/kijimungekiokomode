<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>じゃんけんAI キジムン 改</title> <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.2.0/dist/tf.min.js"></script>
  <style>
    /* CSSは変更なし */
    /* ----- デスクトップ向けスタイル（元のまま） ----- */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f0f2f5;
      margin: 0;
      padding: 20px;
      color: #333;
    }
    #game-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-around;
      align-items: flex-start;
      background-color: #fff;
      padding: 25px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      max-width: 1000px;
      margin: auto;
    }
    #left-panel, #right-panel {
      flex: 1;
      min-width: 400px;
      margin: 10px;
    }
    #left-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #right-panel {
      margin-top: 0px;
    }
    h1 {
      color: #1d4ed8;
      text-align: center;
      margin-bottom: 20px;
    }
    .section-title {
      font-size: 18px;
      font-weight: bold;
      color: #4b5563;
      margin-top: 20px;
      margin-bottom: 10px;
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 5px;
    }
    .choice-btn {
      font-size: 26px;
      padding: 12px 25px;
      margin: 8px;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      background-color: #e5e7eb;
      transition: background-color 0.2s, transform 0.1s;
    }
    .choice-btn:hover { background-color: #d1d5db; }
    .choice-btn:active { transform: scale(0.95); }
    .choice-btn:disabled { cursor: not-allowed; opacity: 0.6; }
    #bluff {
      font-size: 18px;
      margin-bottom: 15px;
      color: #c81e1e;
      min-height: 24px;
      font-weight: bold;
      text-align: center;
      background-color: #fee2e2;
      padding: 8px;
      border-radius: 5px;
      border: 1px solid #fca5a5;
    }
    #face-container { position: relative; margin-bottom: 15px; }
    #face {
      width: 200px;
      display: block;
      margin: 0 auto 10px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    #ai-reasoning {
      position: absolute;
      bottom: -20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.3s, visibility 0.3s;
      z-index: 10;
    }
    #face-container:hover #ai-reasoning {
      visibility: visible;
      opacity: 1;
    }
    #statusText {
      font-size: 36px;
      font-weight: bold;
      margin: 15px 0;
      text-align: center;
    }
    #result {
      margin-top: 10px;
      font-size: 20px;
      min-height: 24px;
      text-align: center;
      font-weight: 500;
    }
    #history {
      margin-top: 10px;
      font-size: 14px;
      color: #666;
      text-align: center;
    }
    #statsInfo {
      margin-top: 10px;
      font-size: 16px;
      color: #444;
      line-height: 1.6;
    }
    #settings {
      background-color: #f9fafb;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
      border: 1px solid #e5e7eb;
    }
    #settings label { margin-right: 10px; font-weight: 500; }
    #settings select,
    #settings input[type="checkbox"] { margin-right: 15px; }
    #debug-info {
      font-size: 12px;
      color: #6b7280;
      margin-top: 15px;
      line-height: 1.4;
      max-height: 100px;
      overflow-y: auto;
      border: 1px dashed #d1d5db;
      padding: 5px;
      text-align: left; /* 左寄せを追加 */
    }
    #buttons button {
      font-size: 24px;
      padding: 10px 20px;
      margin: 10px;
      font-family: Arial, sans-serif;
    }
    #buttons button:hover { background-color: #e0e0e0; }

    /* チャートを縦に広めに */
    #statsChart{
      width: 100% !important;
      height: 280px !important;
    }
    #userHistChart {
      width: 50% !important; /* 右パネル内で半分に */
      height: 280px !important;
      margin: 0 auto; /* 中央揃え */
      display: block; /* 中央揃えのために必要 */
    }

    /* ----- スマホ向けレスポンシブ ----- */
    @media (max-width: 768px) { /* 少し広げてタブレットも考慮 */
       body { padding: 10px; }
       #game-container {
         flex-direction: column;
         padding: 15px;
       }
       #left-panel, #right-panel {
         min-width: auto;
         width: 100%;
         margin: 15px 0;
       }
       h1 { font-size: 20px; line-height: 1.2; }
       .section-title { font-size: 16px; }
       .choice-btn { font-size: 20px; padding: 10px 18px; margin: 6px; }
       #statusText { font-size: 24px; }
       #result { font-size: 18px; }
       #history, #statsInfo { font-size: 14px; }
       #bluff { font-size: 16px; padding: 6px; }
       #face { width: 150px; }
       #settings { padding: 10px; }
       #settings label,
       #settings select,
       #settings input { font-size: 14px; }
       #debug-info { font-size: 10px; max-height: 80px; }
     #statsChart {
       height: 200px !important;
       width: 90% !important;   /* 横幅を90%にしてスマホ画面にフィット */
       max-width: 400px;       /* 最大幅を400pxに制限 */
       margin: 20px auto;      /* 上下余白20px、中央寄せ */
       display: block;         /* 中央寄せのために必要 */
     }
     #userHistChart {
       width: 90% !important;   /* 横幅を90%にして左右に余白 */
       max-width: 400px;       /* 必要なら最大幅も制限 */
       margin: 0 auto 20px;    /* 上余白0px、下余白20px、中央寄せ */
       display: block;
     }
     }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="left-panel">
      <h1>VSッ!!じゃんけんキジムン！！改<br>(先に30勝で勝利さー！)</h1> <div id="settings" style="margin-bottom: 20px; text-align: left;">
        <span class="section-title" style="border: none; margin-bottom: 5px;">設定</span><br>
          <label for="modelType">推論モデルタイプ:</label>
          <select id="modelType">
            <option value="frequency">頻度戦略</option>
            <option value="pattern">パターン戦略+</option> <option value="nn">深層学習戦略</option>
            <option value="hybrid" selected>ハイブリッド戦略+</option> </select>
         <label for="show-reasoning">キジムンの考えを見る:</label>
         <input type="checkbox" id="show-reasoning">
      </div>
      <div id="bluff">キジムン: よーし、じゃんけんするさー！</div>
      <div id="face-container">
        <img id="face" src="" alt="キジムンの表情">
        <span id="ai-reasoning">キジムンの考え</span>
        <div id="statusText">勝負さー！</div>
        <div id="result">あなた vs キジムン</div>
        <div id="hand-images" style="display:flex; justify-content:center; gap:20px; margin-top:10px;">
            <img id="user-hand" src="" alt="あなたの手" width="80" height="80">
            <span style="font-size: 24px; font-weight: bold; align-self: center;">VS</span>
            <img id="ai-hand"   src="" alt="キジムンの手" width="80" height="80">
        </div>
      </div>
      <div id="buttons" style="display: flex; justify-content: center; gap: 10px; margin-top: 10px;">
        <button class="choice-btn" data-choice="グー">👊 グー</button>
        <button class="choice-btn" data-choice="チョキ">✌️ チョキ</button>
        <button class="choice-btn" data-choice="パー">🖐️ パー</button>
      </div>

      <div id="history">履歴: 勝ち(0), 負け(0), あいこ(0)</div>
      <div id="statsInfo">
        勝率: あなた 0.0% / キジムン 0.0%<br>
        最大連勝: あなた 0 回, キジムン 0 回<br>
        現在のパターン長: 1 (ε: 0.000)
      </div>
      <div id="debug-info">デバッグ情報:</div>
    </div>

    <div id="right-panel">
      <div class="section-title" style="margin-top: 0px;">統計グラフ</div>
      <canvas id="statsChart"></canvas>
      <div class="section-title" style="margin-top: 30px;">あなたの手の傾向</div>
      <canvas id="userHistChart"></canvas>
    </div>
  </div>

  <script>
    // --- グローバル変数、定数、UI要素、初期化関数などは基本的に変更なし ---
    let jankenModel;
    let MODEL_SEQ_LEN = 5;
    const trainBuffer = { xs: [], ys: [] };

    async function initJankenModel() {
      try {
        // NNモデルの入力形状を決定（ハイブリッド戦略で追加特徴量を考慮する場合はここを変更）
        // 今回はNNモデル自体の変更はないため、そのままとする
        const inputShape = [MODEL_SEQ_LEN * 3];

        jankenModel = tf.sequential();
        jankenModel.add(tf.layers.dense({
          inputShape: inputShape,
          units: 64,
          activation: 'relu'
        }));
        jankenModel.add(tf.layers.dense({
          units: 32,
          activation: 'relu'
        }));
        jankenModel.add(tf.layers.dense({
          units: 3,
          activation: 'softmax'
        }));
        jankenModel.compile({
          optimizer: tf.train.adam(0.01),
          loss: 'categoricalCrossentropy'
        });
        console.log('Janken NN model initialized');
        debugLog("NNモデル初期化成功さー！");
      } catch (error) {
          console.error("NNモデル初期化失敗:", error);
          debugLog(`NNモデル初期化失敗さー: ${error.message}`);
      }
    }

    const CHOICES = ['グー', 'チョキ', 'パー'];
    const COUNTER_MAP = { 'グー': 'パー', 'チョキ': 'グー', 'パー': 'チョキ' };
    const WIN_TARGET = 30;
    const USER_HAND_IMAGES = { 'グー': 'https://i.imgur.com/cLcVghg.png', 'チョキ':'https://i.imgur.com/vKcKjfs.png', 'パー': 'https://i.imgur.com/WrNhJFY.png' };
    const AI_HAND_IMAGES = { 'グー': 'https://i.imgur.com/pddAFX0.png', 'チョキ':'https://i.imgur.com/Ck8uJzj.png', 'パー': 'https://i.imgur.com/hWtNynY.png' };

    const MODEL_SETTINGS = {
      frequency: { label: '頻度戦略', epsilon: 0.5, seqLen: 1, trainBatch: false, usePatterns: false },
      pattern: { label: 'パターン戦略+', epsilon: 0.25, seqLen: 4, trainBatch: false, usePatterns: true }, // ε少し下げ、seqLen少し長く
      nn: { label: '深層学習戦略', epsilon: 0.1, seqLen: 5, trainBatch: true, usePatterns: false },
      hybrid: { label: 'ハイブリッド戦略+', epsilon: 0.05, seqLen: 5, trainBatch: true, usePatterns: true } // ハイブリッドではパターンも使う
    };

    const IMG_HAPPY = 'https://i.imgur.com/XIwk5uc.png';
    const IMG_SAD = 'https://i.imgur.com/pbDebFC.png';
    const IMG_THINK = 'https://i.imgur.com/VXzFi1K.png';
    const IMG_FINAL_USER = 'https://i.imgur.com/GcezINz.png';
    const IMG_FINAL_AI = 'https://i.imgur.com/8H6y3m0.png';

    let userHistory = { 'グー': 0, 'チョキ': 0, 'パー': 0 };
    let userSequence = [];
    let patternMap = {}; // パターンデータ: { 'グー_チョキ': { 'パー': 5, 'グー': 1, count: 6 }, ... }
    let winLossHistory = [];
    let userWins = 0, aiWins = 0, draws = 0;
    let userStreak = 0, aiStreak = 0, maxUserStreak = 0, maxAiStreak = 0;
    let currentMaxPattern = 1;
    let epsilon = 0.1;
    let useOnlineTraining = false;
    let usePatterns = false;
    let lastUserDistribution = { 'グー': 0, 'チョキ': 0, 'パー': 0 };
    let roundsPlayed = 0;
    let aiReasoning = "";
    let strategicBluff = "";
    let committedAiChoice = null;

    let gameSettings = {
      initialMaxPattern: 2,
      patternGrowthRate: 0.05,
      maxPatternCap: 6, // 最大パターン長を少し伸ばす
      adaptThreshold: 0.18, // 変化検出の閾値を少し下げる
      minEpsilon: 0.01,
      epsilonDecay: 0.996, // εの減衰を少し緩やかに
      patternConfidenceThreshold: 0.6, // パターン予測を採用する信頼度の閾値
      nnConfidenceThreshold: 0.7, // NN予測を採用する信頼度の閾値
      patternForgetRate: 0.9 // 戦略変化時にパターンカウントを減らす割合
    };

    // UI要素取得 (変更なし)
    const userHandEl = document.getElementById('user-hand');
    const aiHandEl   = document.getElementById('ai-hand');
    const bluffEl = document.getElementById('bluff');
    const faceEl = document.getElementById('face');
    const aiReasoningEl = document.getElementById('ai-reasoning');
    const statusTextEl = document.getElementById('statusText');
    const resultEl = document.getElementById('result');
    const historyEl = document.getElementById('history');
    const statsInfoEl = document.getElementById('statsInfo');
    const debugInfoEl = document.getElementById('debug-info');
    const choiceBtns = document.querySelectorAll('.choice-btn');
    const modelTypeSelect = document.getElementById('modelType');
    const showReasoningCheckbox = document.getElementById('show-reasoning');
    const statsCtx = document.getElementById('statsChart').getContext('2d');
    let statsChart = null;
    const userHistCtx = document.getElementById('userHistChart').getContext('2d');
    let userHistChart = null;

    function initializeCharts() {
      if (statsChart) statsChart.destroy();
      if (userHistChart) userHistChart.destroy();

      const maxValue = Math.max(userWins, aiWins, draws);

      statsChart = new Chart(statsCtx, {
        type: 'bar',
        data: {
          labels: ['あなたの勝ち', 'キジムンの勝ち', 'あいこ'],
          datasets: [{
            label: '勝負回数',
            data: [userWins, aiWins, draws],
            backgroundColor: ['#ef4444', '#3b82f6', '#6b7280']
          }]
        },
        options: { /* オプションは変更なし */
           responsive: false,
           maintainAspectRatio: false,
           plugins: { legend: { labels: { font: { size: 14 } } } },
           scales: {
             x: { ticks: { font: { size: 12 } } },
             y: { beginAtZero: true, suggestedMax: Math.max(maxValue + 5, 10), ticks: { precision: 0, font: { size: 12 } } }
           },
           layout: { padding: { top: 10, bottom: 10 } }
        }
      });

      userHistChart = new Chart(userHistCtx, {
        type: 'doughnut',
        data: {
          labels: ['グー', 'チョキ', 'パー'],
          datasets: [{
            label: 'あなたの手の内訳',
            data: [userHistory['グー'], userHistory['チョキ'], userHistory['パー']],
            backgroundColor: ['#f87171', '#fbbf24', '#34d399']
          }]
        },
        options: { /* オプションは変更なし */
            responsive: false,
            maintainAspectRatio: false,
            plugins: {
                legend: { labels: { font: { size: 14 } } },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const data = context.dataset.data;
                            const total = data.reduce((s, v) => s + v, 0);
                            const pct = total ? (context.parsed / total * 100).toFixed(1) : '0.0';
                            return `${context.label}: ${pct}% (${context.parsed}回)`; // 回数も表示
                        }
                    }
                }
            }
        }
      });
    }

    // --- 関数定義 ---

    /**
     * デバッグ情報を表示
     */
    function debugLog(message) {
        const time = new Date().toLocaleTimeString();
        if (debugInfoEl) {
            debugInfoEl.innerHTML = `[${time}] ${message}<br>` + debugInfoEl.innerHTML;
            const lines = debugInfoEl.innerHTML.split('<br>');
            if (lines.length > 51) { // 最大50行表示
                debugInfoEl.innerHTML = lines.slice(0, 50).join('<br>');
            }
        } else {
            console.log(`[DEBUG] ${message}`);
        }
    }


    /**
     * ゲームの初期化またはリセット
     */
    function initGame() {
        debugLog("ゲーム初期化開始さー...");
        // 変数リセット
        committedAiChoice = null;
        userHistory = { 'グー': 0, 'チョキ': 0, 'パー': 0 };
        userSequence = [];
        patternMap = {};
        winLossHistory = [];
        userWins = 0; aiWins = 0; draws = 0;
        userStreak = 0; aiStreak = 0; maxUserStreak = 0; maxAiStreak = 0;
        roundsPlayed = 0;
        lastUserDistribution = { 'グー': 0, 'チョキ': 0, 'パー': 0 };
        aiReasoning = "さあ、始めるよー！";
        strategicBluff = "キジムン: よーし、じゃんけんするさー！";

        // ★★★ 修正: モデルタイプで設定を取得 ★★★
        const modelKey = modelTypeSelect.value;
        const setting = MODEL_SETTINGS[modelKey];
        epsilon = setting.epsilon;
        MODEL_SEQ_LEN = setting.seqLen; // predictUserChoice で参照する入力長
        useOnlineTraining = setting.trainBatch; // オンライン学習フラグ
        usePatterns = setting.usePatterns; // パターン検出フラグ

        // ★★★ 修正: currentMaxPattern を初期化 ★★★
        currentMaxPattern = gameSettings.initialMaxPattern;

        // NNモデルを使う戦略で、モデルが初期化されていない場合は初期化
        if ((modelKey === 'nn' || modelKey === 'hybrid') && !jankenModel) {
            debugLog("NNモデルがまだないから初期化するさー");
            // initJankenModelは非同期なので待つ (実際にはDOMContentLoadedで先に呼ばれる想定)
             initJankenModel(); // ここで呼ぶよりDOMContentLoadedで呼ぶ方が確実
        }


        // UI初期化
        initializeCharts(); // チャートもここで初期化
        updateUI('勝負さー！', '', ''); // 初期状態のUI更新
        faceEl.src = IMG_THINK;
        choiceBtns.forEach(btn => btn.disabled = false);
        // debugInfoEl.innerHTML = "デバッグ情報:"; // デバッグ情報クリア (任意)
        debugLog(`ゲーム初期化完了さー。モデルタイプ: ${setting.label}`);
    }


    /**
     * ユーザーの履歴とパターンを更新
     */
    function updateGameHistory(userChoice) {
        userHistory[userChoice]++;
        userSequence.push(userChoice);
        // userSequenceの長さを制限（例：直近50手など）
        if (userSequence.length > 50) {
            userSequence.shift();
        }

        // パターンマップ更新 (usePatternsがtrueの場合のみ)
        if (usePatterns) {
            // 現在の最大パターン長以下の長さでパターンを記録
            for (let len = 1; len <= Math.min(currentMaxPattern, userSequence.length - 1); len++) {
                // 履歴の末尾からlen+1個前～末尾から1個前までをパターンキーとする
                const patternKey = userSequence.slice(-len - 1, -1).join('_');
                // そのパターンに続いた実際の手
                const nextChoice = userSequence[userSequence.length - 1];

                if (!patternMap[patternKey]) {
                    patternMap[patternKey] = { 'グー': 0, 'チョキ': 0, 'パー': 0, 'count': 0 };
                }
                patternMap[patternKey][nextChoice]++;
                patternMap[patternKey]['count']++;
            }
        }
        // debugLog(`パターンマップ更新: キー数=${Object.keys(patternMap).length}`);
    }

    /**
     * パターン検出の最大長を動的に調整
     */
    function updateDynamicMaxPattern() {
        // usePatterns が true の場合のみパターン長を更新
        if (usePatterns) {
            const potentialMaxPattern = Math.floor(gameSettings.initialMaxPattern + roundsPlayed * gameSettings.patternGrowthRate);
            currentMaxPattern = Math.min(potentialMaxPattern, gameSettings.maxPatternCap);
            // debugLog(`動的パターン長更新: 現在=${currentMaxPattern}`);
        } else {
            currentMaxPattern = 1; // パターンを使わない場合は1固定（または他の適切な値）
        }
    }
        /**
     * ★★★ 改善: 相手の戦略変化を検出し、パターン忘却も行う ★★★
     */
     function detectStrategyChange() {
        if (roundsPlayed < 10) return false;

        const currentDistribution = {};
        let total = 0;
        for(const choice of CHOICES) {
            currentDistribution[choice] = userHistory[choice];
            total += userHistory[choice];
        }
        if (total === 0) return false;

        let diffSum = 0;
        // 前回 (lastUserDistribution) の合計回数を取得
        const lastTotal = lastUserDistribution.total || (roundsPlayed > 0 ? roundsPlayed : 1);

        for(const choice of CHOICES) {
            const currentRate = currentDistribution[choice] / total;
            const lastRate = (lastUserDistribution[choice] || 0) / lastTotal;
            diffSum += Math.abs(currentRate - lastRate);
        }
        const changeMagnitude = diffSum / 2; // 正規化 (0-1)

        // lastUserDistribution を更新
        lastUserDistribution = {...currentDistribution};
        lastUserDistribution.total = total; // 合計回数も保持

        // debugLog(`戦略変化チェック: 変化量=${changeMagnitude.toFixed(3)} (閾値: ${gameSettings.adaptThreshold})`); // ログは任意

        if (changeMagnitude > gameSettings.adaptThreshold) {
            debugLog("おっと、手の出し方が変わったさー？ ちょっと考え直すよー！");
            epsilon = Math.min(1.0, epsilon * 1.5); // 探索率を一時的に上げる

            // ★★★ パターン忘却処理 ★★★
            if (usePatterns) {
                debugLog("古いパターンは忘れようさー...");
                let forgottenCount = 0;
                for (const key in patternMap) {
                    const patternData = patternMap[key];
                    let newTotalCount = 0;
                    for (const choice of CHOICES) {
                        // 各手のカウントを指定率で減らす (小数点以下切り捨て)
                        patternData[choice] = Math.floor(patternData[choice] * gameSettings.patternForgetRate);
                        newTotalCount += patternData[choice];
                    }
                    patternData.count = newTotalCount;
                    // カウントが0になったパターンは削除しても良い
                    if (patternData.count === 0) {
                        delete patternMap[key];
                        forgottenCount++;
                    }
                }
                 debugLog(`${forgottenCount}個の古いパターンを忘れた(または弱めた)さー`);
            }
            return true;
        }
        return false;
    }

    /**
     * 相手の手のランダム性を評価 (エントロピー計算)
     */
     function assessOpponentRandomness() {
        const total = roundsPlayed;
        if (total < 5) return 0.5; // データ不足時は中間値

        let entropy = 0;
        for (const choice of CHOICES) {
            const probability = userHistory[choice] / total;
            if (probability > 0) {
                entropy -= probability * Math.log2(probability);
            }
        }
        // 最大エントロピー (log2(3)) で正規化して 0~1 の値にする
        const normalizedEntropy = entropy / Math.log2(3);
        debugLog(`相手のランダム性チェック: ${normalizedEntropy.toFixed(3)} (1に近いほどランダムさー)`);
        // ランダム性が高い場合、εを上げるなどの調整も可能
        // if (normalizedEntropy > 0.9) epsilon = Math.min(1.0, epsilon + 0.1);
        return normalizedEntropy;
    }

        // =============================================
    // === 予測ロジックの改善 (ここがメイン) ===
    // =============================================

    /**
     * NNモデルによる予測 (信頼度も返す)
     */
     async function predictWithNN() {
        if (!jankenModel || userSequence.length < MODEL_SEQ_LEN) {
            return { predicted: null, confidence: 0, reason: "NNデータ不足" };
        }
        try {
            const seq = userSequence.slice(-MODEL_SEQ_LEN);
            const inputVec = seq.flatMap(c => CHOICES.map(ch => ch === c ? 1 : 0));
            const inputTensor = tf.tensor2d([inputVec]);
            const output = await jankenModel.predict(inputTensor);
            const probs = await output.data();
            inputTensor.dispose();
            output.dispose();

            const maxIdx = probs.indexOf(Math.max(...probs));
            const predicted = CHOICES[maxIdx];
            const confidence = probs[maxIdx];
            const reason = `NN予測(${predicted}, 信:${(confidence * 100).toFixed(0)}%)`;
            // debugLog(reason); // ログは任意
            return { predicted, confidence, reason };
        } catch (error) {
            console.error("NN予測エラー:", error);
            debugLog(`NN予測エラーさー: ${error.message}`);
            return { predicted: null, confidence: 0, reason: "NN予測エラー" };
        }
    }

    /**
     * ★★★ 改善: パターンに基づく予測 (信頼度も返す) ★★★
     */
    function predictWithPatterns() {
        if (!usePatterns || userSequence.length < 1) {
             return { predicted: null, confidence: 0, reason: "パターン未使用または履歴不足" };
        }

        let bestPrediction = null;
        let highestConfidence = -1;
        let bestReason = "有効パターンなし";

        // 最長パターンから順に試す
        for (let len = Math.min(currentMaxPattern, userSequence.length - 1); len >= 1; len--) {
            const patternKey = userSequence.slice(-len - 1, -1).join('_');
            const patternData = patternMap[patternKey];

            if (patternData && patternData.count > 0) { // パターンが存在し、カウントがある
                let predictedForPattern = null;
                let highestFreq = -1;

                // そのパターンで最も多く出された手を探す
                for (const choice of CHOICES) {
                    if (patternData[choice] > highestFreq) {
                        highestFreq = patternData[choice];
                        predictedForPattern = choice;
                    }
                }

                if (predictedForPattern) {
                    // ★★★ 信頼度 = その手が選ばれた回数 / パターンが出現した総回数 ★★★
                    const confidence = highestFreq / patternData.count;
                    const reason = `パターン(${patternKey}→${predictedForPattern}, 信:${(confidence * 100).toFixed(0)}%, ${patternData.count}回)`;

                    // より長く、より信頼度の高いパターンを優先する
                    // (単純に信頼度だけで比較しても良いし、長さも加味しても良い)
                    // ここでは、閾値を超え、かつこれまでで最も信頼度が高いものを採用
                    if (confidence >= gameSettings.patternConfidenceThreshold && confidence > highestConfidence) {
                        highestConfidence = confidence;
                        bestPrediction = predictedForPattern;
                        bestReason = reason;
                        // debugLog(`有力パターン発見: ${reason}`); // ログは任意
                        // 十分信頼できるパターンが見つかれば、それ以上短いパターンは見ないでも良いかも
                         if (len > 1 && confidence > 0.8) break;
                    }
                }
            }
        }

        if (bestPrediction) {
             // debugLog(`パターン予測 結果: ${bestReason}`);
             return { predicted: bestPrediction, confidence: highestConfidence, reason: bestReason };
        } else {
             return { predicted: null, confidence: 0, reason: bestReason };
        }
    }

    /**
     * 頻度に基づく予測 (信頼度も返す)
     */
    function predictWithFrequency() {
        let mostFrequent = null;
        let maxFreq = -1;
        let totalHands = 0;
        for (const choice of CHOICES) {
            totalHands += userHistory[choice];
            if (userHistory[choice] > maxFreq) {
                maxFreq = userHistory[choice];
                mostFrequent = choice;
            }
        }

        if (mostFrequent && totalHands > 0) {
            const confidence = maxFreq / totalHands; // 信頼度 = 最多頻度の手の割合
            const reason = `頻度予測(${mostFrequent}, 信:${(confidence * 100).toFixed(0)}%)`;
             // debugLog(reason); // ログは任意
            return { predicted: mostFrequent, confidence, reason };
        } else {
            return { predicted: null, confidence: 0, reason: "頻度データ不足" };
        }
    }


    /**
     * ★★★ 改善: ユーザーの次の手を予測 (ハイブリッド戦略強化) ★★★
     */
    async function predictUserChoice() {
        const modelKey = modelTypeSelect.value;

        // 各戦略で予測を実行
        const nnPrediction = (modelKey === 'nn' || modelKey === 'hybrid') ? await predictWithNN() : { predicted: null, confidence: 0, reason: "NN未使用" };
        const patternPrediction = (modelKey === 'pattern' || modelKey === 'hybrid') ? predictWithPatterns() : { predicted: null, confidence: 0, reason: "パターン未使用" };
        const frequencyPrediction = predictWithFrequency(); // 頻度は常に計算しておく (フォールバック用)

        let finalPrediction = { predicted: null, confidence: -1, reason: "予測失敗" };

        // --- 戦略タイプごとの予測選択ロジック ---

        if (modelKey === 'nn') {
            if (nnPrediction.confidence >= gameSettings.nnConfidenceThreshold) {
                finalPrediction = nnPrediction;
            } else {
                // NNの信頼度が低い場合は頻度にフォールバック
                finalPrediction = frequencyPrediction;
                finalPrediction.reason = `NN信頼度低(${nnPrediction.reason}) → ${frequencyPrediction.reason}`;
            }
        }
        else if (modelKey === 'pattern') {
            if (patternPrediction.confidence > 0) { // 閾値チェックは predictWithPatterns 内で行う
                finalPrediction = patternPrediction;
            } else {
                // パターンが見つからない場合は頻度にフォールバック
                finalPrediction = frequencyPrediction;
                finalPrediction.reason = `有効パターンなし → ${frequencyPrediction.reason}`;
            }
        }
        else if (modelKey === 'hybrid') {
            // ★ ハイブリッド: NNとパターンの信頼度を比較
            let bestConfidence = -1;
            let chosenReason = "ハイブリッド: ";

            if (nnPrediction.confidence > bestConfidence && nnPrediction.confidence >= gameSettings.nnConfidenceThreshold) {
                bestConfidence = nnPrediction.confidence;
                finalPrediction = nnPrediction;
                chosenReason += `NN優先 (${nnPrediction.reason})`;
            }
            if (patternPrediction.confidence > bestConfidence && patternPrediction.confidence >= gameSettings.patternConfidenceThreshold) {
                // NNよりパターンの方が信頼度が高ければ上書き
                 if (patternPrediction.confidence > nnPrediction.confidence) {
                     bestConfidence = patternPrediction.confidence;
                     finalPrediction = patternPrediction;
                     chosenReason += `パターン優先 (${patternPrediction.reason})`;
                 } else if (finalPrediction.predicted === null) {
                     // NNの信頼度が閾値未満で、パターンが閾値以上の場合
                     bestConfidence = patternPrediction.confidence;
                     finalPrediction = patternPrediction;
                     chosenReason += `パターン採用 (${patternPrediction.reason})`;
                 }
            }

            // NNもパターンも信頼度が低い、または予測できなかった場合
            if (finalPrediction.predicted === null) {
                finalPrediction = frequencyPrediction;
                chosenReason += `NN/パターン信頼度低 → ${frequencyPrediction.reason}`;
            }
            finalPrediction.reason = chosenReason; // 最終的な理由を更新

        }
        else { // frequency または予期せぬモデルキー
            finalPrediction = frequencyPrediction;
        }

        // 最終的にどの戦略でも予測できなかった場合 (初期状態など) はランダム
        if (finalPrediction.predicted === null) {
            finalPrediction.predicted = CHOICES[Math.floor(Math.random() * 3)];
            finalPrediction.confidence = 1/3;
            finalPrediction.reason = `全戦略失敗 → ランダム(${finalPrediction.predicted})`;
        }

        debugLog(`最終予測: ${finalPrediction.predicted} (理由: ${finalPrediction.reason})`);
        // chooseAIHand に渡すのは予測された手と、最終的な理由
        return { predicted: finalPrediction.predicted, reason: finalPrediction.reason, confidence: finalPrediction.confidence };
    }


    // --- chooseAIHand, determineOutcome, updateGameState, generateStrategicBluff, updateUI, checkGameEnd, playRound は基本的に変更なし ---
    // (predictUserChoice の返り値が変わったので、chooseAIHand の呼び出し元 playRound で confidence を受け取る必要はなくなった)
    function chooseAIHand(predictedChoice, predictionReason /*, predictionConfidence は削除 */) {
        let aiChoice, reason;
        // const adjustedEpsilon = epsilon / (predictionConfidence + 0.1); // 信頼度に応じたε調整も可能だが今回はシンプルに

        if (Math.random() < epsilon) {
            aiChoice = CHOICES[Math.floor(Math.random() * 3)];
            reason = `ε-greedy ランダム探索 (ε=${epsilon.toFixed(3)}) → ${aiChoice}`; // εの桁数調整
        } else {
            aiChoice = COUNTER_MAP[predictedChoice] || CHOICES[Math.floor(Math.random()*3)];
            reason = `${predictionReason} → それに勝つ ${aiChoice} を選択`;
        }
        // debugLog(`AI手決定: ${aiChoice} (理由: ${reason})`); // playRound内でaiReasoningに格納するのでここでは不要かも
        return { aiChoice, reason }; // reasonには予測の根拠と最終決定理由が含まれる
    }

        /**
     * 勝敗を判定
     */
     function determineOutcome(userChoice, aiChoice) {
        if (userChoice === aiChoice) {
            return '引き分け';
        } else if (COUNTER_MAP[aiChoice] === userChoice) {
            return '勝ち'; // ユーザーの勝ち
        } else {
            return '負け'; // ユーザーの負け (AIの勝ち)
        }
    }

    /**
     * ゲーム状態を更新
     */
    function updateGameState(outcome, userChoice, aiChoice) {
        roundsPlayed++;
        winLossHistory.push([outcome, userChoice, aiChoice]); // [結果, ユーザーの手, AIの手]

        if (outcome === '勝ち') {
            userWins++;
            userStreak++;
            aiStreak = 0;
            maxUserStreak = Math.max(maxUserStreak, userStreak);
        } else if (outcome === '負け') {
            aiWins++;
            aiStreak++;
            userStreak = 0;
            maxAiStreak = Math.max(maxAiStreak, aiStreak);
        } else {
            draws++;
            userStreak = 0;
            aiStreak = 0;
        }

        // ε-greedy法の探索率を減衰させる
        epsilon = Math.max(gameSettings.minEpsilon, epsilon * gameSettings.epsilonDecay);

        debugLog(`結果更新: Round ${roundsPlayed}, 結果: ${outcome}, User: ${userChoice}, AI: ${aiChoice}, ε: ${epsilon.toFixed(3)}`);

        // --- オンラインでモデルを学習 (useOnlineTraining が true の場合) ---
        if (useOnlineTraining && jankenModel && userSequence.length > MODEL_SEQ_LEN) {
            (async () => { // 非同期処理として実行
               try {
                   const inputSeq = userSequence.slice(-MODEL_SEQ_LEN - 1, -1); // 最新の手の直前まで
                   const nextMove = userSequence[userSequence.length - 1]; // 最新の手 (正解ラベル)

                   const xs = inputSeq.flatMap(c => CHOICES.map(ch => ch === c ? 1 : 0));
                   const ys = CHOICES.map(ch => ch === nextMove ? 1 : 0);

                   // バッファに追加
                   trainBuffer.xs.push(xs);
                   trainBuffer.ys.push(ys);

                   // バッファが一定数貯まったら学習実行
                   const BATCH_SIZE = 10; // 10回分のデータが貯まったら学習
                   if (trainBuffer.xs.length >= BATCH_SIZE) {
                       debugLog(`NN学習開始さー (データ ${BATCH_SIZE}件)`);
                       const xsTensor = tf.tensor2d(trainBuffer.xs);
                       const ysTensor = tf.tensor2d(trainBuffer.ys);
                       // 学習 (fitは非同期)
                       const history = await jankenModel.fit(xsTensor, ysTensor, {
                           epochs: 5, // エポック数 (適宜調整)
                           batchSize: BATCH_SIZE, // バッチサイズ
                           // validationSplit: 0.1 // 検証データを使う場合
                       });
                       xsTensor.dispose();
                       ysTensor.dispose();
                       // バッファをクリア
                       trainBuffer.xs = [];
                       trainBuffer.ys = [];
                       debugLog(`NN学習完了さー (Loss: ${history.history.loss[history.history.loss.length - 1].toFixed(4)})`);
                   }
               } catch (error) {
                   console.error("NNオンライン学習エラー:", error);
                   debugLog(`NNオンライン学習エラーさー: ${error.message}`);
                   // 学習エラーが頻発する場合、useOnlineTrainingをfalseにするなどの対策も
                   // useOnlineTraining = false;
               }
            })(); // 非同期関数を実行
        }
    }

    /**
     * 戦略的なブラフを生成 (キジムン風)
     */
    function generateStrategicBluff(predictedChoice, lastAiChoice, lastUserChoice, lastOutcome) {
        const bluffs = [];
        bluffs.push(`キジムン: 次はおいら、${CHOICES[Math.floor(Math.random() * 3)]}をだすよ～！`); // ランダムな宣言

        if(predictedChoice){
            bluffs.push(`キジムン: ふむふむ、次は${predictedChoice}で来るはずさー！`);
            bluffs.push(`キジムン: ${predictedChoice}には、${COUNTER_MAP[predictedChoice]}さー！これどう？`); // 相手の手に勝つ手を宣言
        }
        if(lastOutcome === '負け' && lastUserChoice){ // AIが負けた場合
            bluffs.push(`キジムン: うぐぐ、さっきの${lastUserChoice}は強かったさー！`);
            bluffs.push(`キジムン: 同じ手(${lastUserChoice})にはもう引っかからないよー！`);
        }
        if(lastOutcome === '勝ち' && lastAiChoice){ // AIが勝った場合
            bluffs.push(`キジムン: ${lastAiChoice}が決まったねー！もう一回いくさー？`);
        }
        if(aiStreak >= 2){
            bluffs.push(`キジムン: ${aiStreak}連勝さー！ おいら絶好調だよー！`);
        }
        if(userStreak >= 2){
            bluffs.push(`キジムン: ${userStreak}連勝とはやるねー！でも、次はおいらが勝つさー！`);
        }
        // 最近よく出す手について言及
        const userHandCounts = Object.entries(userHistory).sort(([,a],[,b]) => b-a);
        if (roundsPlayed > 5 && userHandCounts[0][1] > roundsPlayed * 0.5) {
            bluffs.push(`キジムン: ${userHandCounts[0][0]}ばっかり出すねー！読めてきたさー！`);
        }


        strategicBluff = bluffs[Math.floor(Math.random() * bluffs.length)];
        // debugLog(`ブラフ生成: ${strategicBluff}`);
    }


    /**
     * UIを更新する
     */
    function updateUI(outcome, userChoice, aiChoice) {
        let imgSrc = IMG_THINK; // デフォルトは考え中
        let statusColor = '#333'; // デフォルトカラー
        let outcomeText = outcome; // デフォルトテキスト

        if (outcome === '勝ち') { // ユーザーの勝ち
            imgSrc = IMG_SAD; statusColor = '#ef4444'; outcomeText = "あなたの勝ち！";
        } else if (outcome === '負け') { // ユーザーの負け
            imgSrc = IMG_HAPPY; statusColor = '#3b82f6'; outcomeText = "キジムンの勝ち！";
        } else if (outcome === '引き分け') {
            imgSrc = IMG_THINK; statusColor = '#6b7280'; outcomeText = "あいこ！もう一回！";
        }
        // ゲーム終了時は checkGameEnd で上書きされる

        faceEl.src = imgSrc;
        statusTextEl.textContent = outcomeText;
        statusTextEl.style.color = statusColor;


        // 手の表示
        if (userChoice && aiChoice) {
            resultEl.textContent = `あなた: ${userChoice} vs キジムン: ${aiChoice}`;
            userHandEl.src = USER_HAND_IMAGES[userChoice] || '';
            aiHandEl.src   = AI_HAND_IMAGES[aiChoice]   || '';
        } else {
            resultEl.textContent = `あなた vs キジムン`;
            userHandEl.src = '';
            aiHandEl.src   = '';
        }

        // 履歴と統計情報
        historyEl.textContent = `履歴: 勝ち(${userWins}), 負け(${aiWins}), あいこ(${draws}) / ${roundsPlayed}回戦`;

        const totalGames = userWins + aiWins + draws;
        const userRate = totalGames > 0 ? (userWins / totalGames * 100).toFixed(1) : '0.0';
        const aiRate = totalGames > 0 ? (aiWins / totalGames * 100).toFixed(1) : '0.0';
        statsInfoEl.innerHTML =
          `勝率: あなた ${userRate}% / キジムン ${aiRate}%<br>` +
          `最大連勝: あなた ${maxUserStreak} 回, キジムン ${maxAiStreak} 回<br>` +
          `現在のパターン長: ${currentMaxPattern} (ε: ${epsilon.toFixed(3)})`; // εも表示

        // グラフ更新 (チャートが初期化済みか確認)
        if (statsChart && userHistChart) {
            statsChart.data.datasets[0].data = [userWins, aiWins, draws];
            // Y軸の最大値を動的に更新
            statsChart.options.scales.y.suggestedMax = Math.max(userWins, aiWins, draws) + 5;
            statsChart.update();

            userHistChart.data.datasets[0].data = [userHistory['グー'], userHistory['チョキ'], userHistory['パー']];
            userHistChart.update();
        }

        // AI思考表示
        aiReasoningEl.textContent = aiReasoning; // playRoundで設定された思考を表示
        aiReasoningEl.style.visibility = showReasoningCheckbox.checked ? 'visible' : 'hidden';
        aiReasoningEl.style.opacity = showReasoningCheckbox.checked ? '1' : '0';

        // ブラフ表示
        bluffEl.textContent = strategicBluff; // generateStrategicBluffで設定されたブラフを表示
    }

    /**
     * ゲーム終了かチェック
     */
     function checkGameEnd() {
         if (userWins >= WIN_TARGET || aiWins >= WIN_TARGET) {
             choiceBtns.forEach(btn => btn.disabled = true); // ボタン無効化
             const winner = userWins >= WIN_TARGET ? 'あなた' : 'キジムン';
             const finalImg = winner === 'あなた' ? IMG_FINAL_USER : IMG_FINAL_AI;
             const finalColor = winner === 'あなた' ? '#ef4444' : '#3b82f6';
             const finalBluff = winner === 'あなた'
                 ? "キジムン: わー！負けちゃったさー！すごいねー！"
                 : "キジムン: やったー！おいらの勝ちさー！";

             statusTextEl.innerHTML = `勝負あり！<br>${winner}の勝ちさー！`;
             statusTextEl.style.color = finalColor;
             faceEl.src = finalImg;
             bluffEl.textContent = finalBluff;
             aiReasoning = "ゲーム終わりさー！";
             aiReasoningEl.textContent = aiReasoning; // 最後の思考を表示
             // 思考表示を強制的にONにするなどしても良いかも
             // aiReasoningEl.style.visibility = 'visible';
             // aiReasoningEl.style.opacity = '1';

             debugLog(`ゲーム終了さー。勝者: ${winner}`);
             return true; // ゲーム終了
         }
         return false; // ゲーム続行
     }
    /**
     * 1ラウンド実行 (predictUserChoice の呼び出し部分変更)
     */
     async function playRound(userChoice) {
        if (checkGameEnd()) return;

        debugLog(`--- Round ${roundsPlayed + 1} 開始さー ---`);
        debugLog(`あなたの手: ${userChoice}`);
        choiceBtns.forEach(btn => btn.disabled = true);

        updateGameHistory(userChoice);
        detectStrategyChange(); // ★ パターン忘却処理を含む可能性あり
        assessOpponentRandomness();
        updateDynamicMaxPattern();

        // ★ 予測実行 (返り値に confidence も含むが、chooseAIHand では直接使わない)
        const prediction = await predictUserChoice();

        // ★ AIの手を決定 (予測結果と理由を渡す)
        const aiDecision = chooseAIHand(prediction.predicted, prediction.reason);
        const currentAiChoice = aiDecision.aiChoice;
        aiReasoning = aiDecision.reason; // ★ AIの思考理由を格納

        const outcome = determineOutcome(userChoice, currentAiChoice);
        updateGameState(outcome, userChoice, currentAiChoice); // ★ オンライン学習もここ
        updateUI(outcome, userChoice, currentAiChoice); // ★ UI更新

        if (!checkGameEnd()) {
            // 次のブラフ生成 (次の予測は generateStrategicBluff 内で行う必要があれば行う)
             const lastOutcome = outcome;
             const lastUserChoice = userChoice;
             const lastAiChoice = currentAiChoice;
             // generateStrategicBluff に渡す predictedChoice はオプション。なくても動作する。
             // 必要なら再度 predictUserChoice を呼ぶ
             // const nextPredictionForBluff = await predictUserChoice();
             generateStrategicBluff(prediction.predicted, lastAiChoice, lastUserChoice, lastOutcome);
             bluffEl.textContent = strategicBluff;

            choiceBtns.forEach(btn => btn.disabled = false);
        }

        debugLog(`--- Round ${roundsPlayed} 終了さー ---`);
    }

    // --- イベントリスナー ---
    choiceBtns.forEach(btn => {
        btn.addEventListener('click', async () => {
            // playRound は非同期なので await する
            await playRound(btn.dataset.choice);
        });
      });

    modelTypeSelect.addEventListener('change', initGame); // モデルタイプ変更時にゲームをリセット

    showReasoningCheckbox.addEventListener('change', ()=>{
        // チェックボックスの状態が変わったら即座に思考の表示/非表示を切り替え
        aiReasoningEl.style.visibility = showReasoningCheckbox.checked ? 'visible' : 'hidden';
        aiReasoningEl.style.opacity = showReasoningCheckbox.checked ? '1' : '0';
    });


    // --- ゲーム開始 ---
    document.addEventListener('DOMContentLoaded', async (event) => {
        debugLog("DOM読み込み完了さー。");
        // ★修正: NNモデルの初期化を待つ
        await initJankenModel(); // NNモデルを初期化 (非同期)
        initGame(); // ゲーム状態を初期化
    });

  </script>
</body>
</html>
