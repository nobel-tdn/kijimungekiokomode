<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ã˜ã‚ƒã‚“ã‘ã‚“AI ã‚­ã‚¸ãƒ ãƒ³ æ”¹</title> <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.2.0/dist/tf.min.js"></script>
  <style>
    /* CSSã¯å¤‰æ›´ãªã— */
    /* ----- ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—å‘ã‘ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆå…ƒã®ã¾ã¾ï¼‰ ----- */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f0f2f5;
      margin: 0;
      padding: 20px;
      color: #333;
    }
    #game-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-around;
      align-items: flex-start;
      background-color: #fff;
      padding: 25px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      max-width: 1000px;
      margin: auto;
    }
    #left-panel, #right-panel {
      flex: 1;
      min-width: 400px;
      margin: 10px;
    }
    #left-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #right-panel {
      margin-top: 0px;
    }
    h1 {
      color: #1d4ed8;
      text-align: center;
      margin-bottom: 20px;
    }
    .section-title {
      font-size: 18px;
      font-weight: bold;
      color: #4b5563;
      margin-top: 20px;
      margin-bottom: 10px;
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 5px;
    }
    .choice-btn {
      font-size: 26px;
      padding: 12px 25px;
      margin: 8px;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      background-color: #e5e7eb;
      transition: background-color 0.2s, transform 0.1s;
    }
    .choice-btn:hover { background-color: #d1d5db; }
    .choice-btn:active { transform: scale(0.95); }
    .choice-btn:disabled { cursor: not-allowed; opacity: 0.6; }
    #bluff {
      font-size: 18px;
      margin-bottom: 15px;
      color: #c81e1e;
      min-height: 24px;
      font-weight: bold;
      text-align: center;
      background-color: #fee2e2;
      padding: 8px;
      border-radius: 5px;
      border: 1px solid #fca5a5;
    }
    #face-container { position: relative; margin-bottom: 15px; }
    #face {
      width: 200px;
      display: block;
      margin: 0 auto 10px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    #ai-reasoning {
      position: absolute;
      bottom: -20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.3s, visibility 0.3s;
      z-index: 10;
    }
    #face-container:hover #ai-reasoning {
      visibility: visible;
      opacity: 1;
    }
    #statusText {
      font-size: 36px;
      font-weight: bold;
      margin: 15px 0;
      text-align: center;
    }
    #result {
      margin-top: 10px;
      font-size: 20px;
      min-height: 24px;
      text-align: center;
      font-weight: 500;
    }
    #history {
      margin-top: 10px;
      font-size: 14px;
      color: #666;
      text-align: center;
    }
    #statsInfo {
      margin-top: 10px;
      font-size: 16px;
      color: #444;
      line-height: 1.6;
    }
    #settings {
      background-color: #f9fafb;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
      border: 1px solid #e5e7eb;
    }
    #settings label { margin-right: 10px; font-weight: 500; }
    #settings select,
    #settings input[type="checkbox"] { margin-right: 15px; }
    #debug-info {
      font-size: 12px;
      color: #6b7280;
      margin-top: 15px;
      line-height: 1.4;
      max-height: 100px;
      overflow-y: auto;
      border: 1px dashed #d1d5db;
      padding: 5px;
      text-align: left; /* å·¦å¯„ã›ã‚’è¿½åŠ  */
    }
    #buttons button {
      font-size: 24px;
      padding: 10px 20px;
      margin: 10px;
      font-family: Arial, sans-serif;
    }
    #buttons button:hover { background-color: #e0e0e0; }

    /* ãƒãƒ£ãƒ¼ãƒˆã‚’ç¸¦ã«åºƒã‚ã« */
    #statsChart{
      width: 100% !important;
      height: 280px !important;
    }
    #userHistChart {
      width: 50% !important; /* å³ãƒ‘ãƒãƒ«å†…ã§åŠåˆ†ã« */
      height: 280px !important;
      margin: 0 auto; /* ä¸­å¤®æƒãˆ */
      display: block; /* ä¸­å¤®æƒãˆã®ãŸã‚ã«å¿…è¦ */
    }

    /* ----- ã‚¹ãƒãƒ›å‘ã‘ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ– ----- */
    @media (max-width: 768px) { /* å°‘ã—åºƒã’ã¦ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆã‚‚è€ƒæ…® */
       body { padding: 10px; }
       #game-container {
         flex-direction: column;
         padding: 15px;
       }
       #left-panel, #right-panel {
         min-width: auto;
         width: 100%;
         margin: 15px 0;
       }
       h1 { font-size: 20px; line-height: 1.2; }
       .section-title { font-size: 16px; }
       .choice-btn { font-size: 20px; padding: 10px 18px; margin: 6px; }
       #statusText { font-size: 24px; }
       #result { font-size: 18px; }
       #history, #statsInfo { font-size: 14px; }
       #bluff { font-size: 16px; padding: 6px; }
       #face { width: 150px; }
       #settings { padding: 10px; }
       #settings label,
       #settings select,
       #settings input { font-size: 14px; }
       #debug-info { font-size: 10px; max-height: 80px; }
     #statsChart {
       height: 200px !important;
       width: 90% !important;   /* æ¨ªå¹…ã‚’90%ã«ã—ã¦ã‚¹ãƒãƒ›ç”»é¢ã«ãƒ•ã‚£ãƒƒãƒˆ */
       max-width: 400px;       /* æœ€å¤§å¹…ã‚’400pxã«åˆ¶é™ */
       margin: 20px auto;      /* ä¸Šä¸‹ä½™ç™½20pxã€ä¸­å¤®å¯„ã› */
       display: block;         /* ä¸­å¤®å¯„ã›ã®ãŸã‚ã«å¿…è¦ */
     }
     #userHistChart {
       width: 90% !important;   /* æ¨ªå¹…ã‚’90%ã«ã—ã¦å·¦å³ã«ä½™ç™½ */
       max-width: 400px;       /* å¿…è¦ãªã‚‰æœ€å¤§å¹…ã‚‚åˆ¶é™ */
       margin: 0 auto 20px;    /* ä¸Šä½™ç™½0pxã€ä¸‹ä½™ç™½20pxã€ä¸­å¤®å¯„ã› */
       display: block;
     }
     }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="left-panel">
      <h1>VSãƒƒ!!ã˜ã‚ƒã‚“ã‘ã‚“ã‚­ã‚¸ãƒ ãƒ³ï¼ï¼æ”¹<br>(å…ˆã«30å‹ã§å‹åˆ©ã•ãƒ¼ï¼)</h1> <div id="settings" style="margin-bottom: 20px; text-align: left;">
        <span class="section-title" style="border: none; margin-bottom: 5px;">è¨­å®š</span><br>
          <label for="modelType">æ¨è«–ãƒ¢ãƒ‡ãƒ«ã‚¿ã‚¤ãƒ—:</label>
          <select id="modelType">
            <option value="frequency">é »åº¦æˆ¦ç•¥</option>
            <option value="pattern">ãƒ‘ã‚¿ãƒ¼ãƒ³æˆ¦ç•¥+</option> <option value="nn">æ·±å±¤å­¦ç¿’æˆ¦ç•¥</option>
            <option value="hybrid" selected>ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰æˆ¦ç•¥+</option> </select>
         <label for="show-reasoning">ã‚­ã‚¸ãƒ ãƒ³ã®è€ƒãˆã‚’è¦‹ã‚‹:</label>
         <input type="checkbox" id="show-reasoning">
      </div>
      <div id="bluff">ã‚­ã‚¸ãƒ ãƒ³: ã‚ˆãƒ¼ã—ã€ã˜ã‚ƒã‚“ã‘ã‚“ã™ã‚‹ã•ãƒ¼ï¼</div>
      <div id="face-container">
        <img id="face" src="" alt="ã‚­ã‚¸ãƒ ãƒ³ã®è¡¨æƒ…">
        <span id="ai-reasoning">ã‚­ã‚¸ãƒ ãƒ³ã®è€ƒãˆ</span>
        <div id="statusText">å‹è² ã•ãƒ¼ï¼</div>
        <div id="result">ã‚ãªãŸ vs ã‚­ã‚¸ãƒ ãƒ³</div>
        <div id="hand-images" style="display:flex; justify-content:center; gap:20px; margin-top:10px;">
            <img id="user-hand" src="" alt="ã‚ãªãŸã®æ‰‹" width="80" height="80">
            <span style="font-size: 24px; font-weight: bold; align-self: center;">VS</span>
            <img id="ai-hand"   src="" alt="ã‚­ã‚¸ãƒ ãƒ³ã®æ‰‹" width="80" height="80">
        </div>
      </div>
      <div id="buttons" style="display: flex; justify-content: center; gap: 10px; margin-top: 10px;">
        <button class="choice-btn" data-choice="ã‚°ãƒ¼">ğŸ‘Š ã‚°ãƒ¼</button>
        <button class="choice-btn" data-choice="ãƒãƒ§ã‚­">âœŒï¸ ãƒãƒ§ã‚­</button>
        <button class="choice-btn" data-choice="ãƒ‘ãƒ¼">ğŸ–ï¸ ãƒ‘ãƒ¼</button>
      </div>

      <div id="history">å±¥æ­´: å‹ã¡(0), è² ã‘(0), ã‚ã„ã“(0)</div>
      <div id="statsInfo">
        å‹ç‡: ã‚ãªãŸ 0.0% / ã‚­ã‚¸ãƒ ãƒ³ 0.0%<br>
        æœ€å¤§é€£å‹: ã‚ãªãŸ 0 å›, ã‚­ã‚¸ãƒ ãƒ³ 0 å›<br>
        ç¾åœ¨ã®ãƒ‘ã‚¿ãƒ¼ãƒ³é•·: 1 (Îµ: 0.000)
      </div>
      <div id="debug-info">ãƒ‡ãƒãƒƒã‚°æƒ…å ±:</div>
    </div>

    <div id="right-panel">
      <div class="section-title" style="margin-top: 0px;">çµ±è¨ˆã‚°ãƒ©ãƒ•</div>
      <canvas id="statsChart"></canvas>
      <div class="section-title" style="margin-top: 30px;">ã‚ãªãŸã®æ‰‹ã®å‚¾å‘</div>
      <canvas id="userHistChart"></canvas>
    </div>
  </div>

  <script>
    // --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã€å®šæ•°ã€UIè¦ç´ ã€åˆæœŸåŒ–é–¢æ•°ãªã©ã¯åŸºæœ¬çš„ã«å¤‰æ›´ãªã— ---
    let jankenModel;
    let MODEL_SEQ_LEN = 5;
    const trainBuffer = { xs: [], ys: [] };

    async function initJankenModel() {
      try {
        // NNãƒ¢ãƒ‡ãƒ«ã®å…¥åŠ›å½¢çŠ¶ã‚’æ±ºå®šï¼ˆãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰æˆ¦ç•¥ã§è¿½åŠ ç‰¹å¾´é‡ã‚’è€ƒæ…®ã™ã‚‹å ´åˆã¯ã“ã“ã‚’å¤‰æ›´ï¼‰
        // ä»Šå›ã¯NNãƒ¢ãƒ‡ãƒ«è‡ªä½“ã®å¤‰æ›´ã¯ãªã„ãŸã‚ã€ãã®ã¾ã¾ã¨ã™ã‚‹
        const inputShape = [MODEL_SEQ_LEN * 3];

        jankenModel = tf.sequential();
        jankenModel.add(tf.layers.dense({
          inputShape: inputShape,
          units: 64,
          activation: 'relu'
        }));
        jankenModel.add(tf.layers.dense({
          units: 32,
          activation: 'relu'
        }));
        jankenModel.add(tf.layers.dense({
          units: 3,
          activation: 'softmax'
        }));
        jankenModel.compile({
          optimizer: tf.train.adam(0.01),
          loss: 'categoricalCrossentropy'
        });
        console.log('Janken NN model initialized');
        debugLog("NNãƒ¢ãƒ‡ãƒ«åˆæœŸåŒ–æˆåŠŸã•ãƒ¼ï¼");
      } catch (error) {
          console.error("NNãƒ¢ãƒ‡ãƒ«åˆæœŸåŒ–å¤±æ•—:", error);
          debugLog(`NNãƒ¢ãƒ‡ãƒ«åˆæœŸåŒ–å¤±æ•—ã•ãƒ¼: ${error.message}`);
      }
    }

    const CHOICES = ['ã‚°ãƒ¼', 'ãƒãƒ§ã‚­', 'ãƒ‘ãƒ¼'];
    const COUNTER_MAP = { 'ã‚°ãƒ¼': 'ãƒ‘ãƒ¼', 'ãƒãƒ§ã‚­': 'ã‚°ãƒ¼', 'ãƒ‘ãƒ¼': 'ãƒãƒ§ã‚­' };
    const WIN_TARGET = 30;
    const USER_HAND_IMAGES = { 'ã‚°ãƒ¼': 'https://i.imgur.com/cLcVghg.png', 'ãƒãƒ§ã‚­':'https://i.imgur.com/vKcKjfs.png', 'ãƒ‘ãƒ¼': 'https://i.imgur.com/WrNhJFY.png' };
    const AI_HAND_IMAGES = { 'ã‚°ãƒ¼': 'https://i.imgur.com/pddAFX0.png', 'ãƒãƒ§ã‚­':'https://i.imgur.com/Ck8uJzj.png', 'ãƒ‘ãƒ¼': 'https://i.imgur.com/hWtNynY.png' };

    const MODEL_SETTINGS = {
      frequency: { label: 'é »åº¦æˆ¦ç•¥', epsilon: 0.5, seqLen: 1, trainBatch: false, usePatterns: false },
      pattern: { label: 'ãƒ‘ã‚¿ãƒ¼ãƒ³æˆ¦ç•¥+', epsilon: 0.25, seqLen: 4, trainBatch: false, usePatterns: true }, // Îµå°‘ã—ä¸‹ã’ã€seqLenå°‘ã—é•·ã
      nn: { label: 'æ·±å±¤å­¦ç¿’æˆ¦ç•¥', epsilon: 0.1, seqLen: 5, trainBatch: true, usePatterns: false },
      hybrid: { label: 'ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰æˆ¦ç•¥+', epsilon: 0.05, seqLen: 5, trainBatch: true, usePatterns: true } // ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ã§ã¯ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚‚ä½¿ã†
    };

    const IMG_HAPPY = 'https://i.imgur.com/XIwk5uc.png';
    const IMG_SAD = 'https://i.imgur.com/pbDebFC.png';
    const IMG_THINK = 'https://i.imgur.com/VXzFi1K.png';
    const IMG_FINAL_USER = 'https://i.imgur.com/GcezINz.png';
    const IMG_FINAL_AI = 'https://i.imgur.com/8H6y3m0.png';

    let userHistory = { 'ã‚°ãƒ¼': 0, 'ãƒãƒ§ã‚­': 0, 'ãƒ‘ãƒ¼': 0 };
    let userSequence = [];
    let patternMap = {}; // ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒ‡ãƒ¼ã‚¿: { 'ã‚°ãƒ¼_ãƒãƒ§ã‚­': { 'ãƒ‘ãƒ¼': 5, 'ã‚°ãƒ¼': 1, count: 6 }, ... }
    let winLossHistory = [];
    let userWins = 0, aiWins = 0, draws = 0;
    let userStreak = 0, aiStreak = 0, maxUserStreak = 0, maxAiStreak = 0;
    let currentMaxPattern = 1;
    let epsilon = 0.1;
    let useOnlineTraining = false;
    let usePatterns = false;
    let lastUserDistribution = { 'ã‚°ãƒ¼': 0, 'ãƒãƒ§ã‚­': 0, 'ãƒ‘ãƒ¼': 0 };
    let roundsPlayed = 0;
    let aiReasoning = "";
    let strategicBluff = "";
    let committedAiChoice = null;

    let gameSettings = {
      initialMaxPattern: 2,
      patternGrowthRate: 0.05,
      maxPatternCap: 6, // æœ€å¤§ãƒ‘ã‚¿ãƒ¼ãƒ³é•·ã‚’å°‘ã—ä¼¸ã°ã™
      adaptThreshold: 0.18, // å¤‰åŒ–æ¤œå‡ºã®é–¾å€¤ã‚’å°‘ã—ä¸‹ã’ã‚‹
      minEpsilon: 0.01,
      epsilonDecay: 0.996, // Îµã®æ¸›è¡°ã‚’å°‘ã—ç·©ã‚„ã‹ã«
      patternConfidenceThreshold: 0.6, // ãƒ‘ã‚¿ãƒ¼ãƒ³äºˆæ¸¬ã‚’æ¡ç”¨ã™ã‚‹ä¿¡é ¼åº¦ã®é–¾å€¤
      nnConfidenceThreshold: 0.7, // NNäºˆæ¸¬ã‚’æ¡ç”¨ã™ã‚‹ä¿¡é ¼åº¦ã®é–¾å€¤
      patternForgetRate: 0.9 // æˆ¦ç•¥å¤‰åŒ–æ™‚ã«ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚«ã‚¦ãƒ³ãƒˆã‚’æ¸›ã‚‰ã™å‰²åˆ
    };

    // UIè¦ç´ å–å¾— (å¤‰æ›´ãªã—)
    const userHandEl = document.getElementById('user-hand');
    const aiHandEl   = document.getElementById('ai-hand');
    const bluffEl = document.getElementById('bluff');
    const faceEl = document.getElementById('face');
    const aiReasoningEl = document.getElementById('ai-reasoning');
    const statusTextEl = document.getElementById('statusText');
    const resultEl = document.getElementById('result');
    const historyEl = document.getElementById('history');
    const statsInfoEl = document.getElementById('statsInfo');
    const debugInfoEl = document.getElementById('debug-info');
    const choiceBtns = document.querySelectorAll('.choice-btn');
    const modelTypeSelect = document.getElementById('modelType');
    const showReasoningCheckbox = document.getElementById('show-reasoning');
    const statsCtx = document.getElementById('statsChart').getContext('2d');
    let statsChart = null;
    const userHistCtx = document.getElementById('userHistChart').getContext('2d');
    let userHistChart = null;

    function initializeCharts() {
      if (statsChart) statsChart.destroy();
      if (userHistChart) userHistChart.destroy();

      const maxValue = Math.max(userWins, aiWins, draws);

      statsChart = new Chart(statsCtx, {
        type: 'bar',
        data: {
          labels: ['ã‚ãªãŸã®å‹ã¡', 'ã‚­ã‚¸ãƒ ãƒ³ã®å‹ã¡', 'ã‚ã„ã“'],
          datasets: [{
            label: 'å‹è² å›æ•°',
            data: [userWins, aiWins, draws],
            backgroundColor: ['#ef4444', '#3b82f6', '#6b7280']
          }]
        },
        options: { /* ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯å¤‰æ›´ãªã— */
           responsive: false,
           maintainAspectRatio: false,
           plugins: { legend: { labels: { font: { size: 14 } } } },
           scales: {
             x: { ticks: { font: { size: 12 } } },
             y: { beginAtZero: true, suggestedMax: Math.max(maxValue + 5, 10), ticks: { precision: 0, font: { size: 12 } } }
           },
           layout: { padding: { top: 10, bottom: 10 } }
        }
      });

      userHistChart = new Chart(userHistCtx, {
        type: 'doughnut',
        data: {
          labels: ['ã‚°ãƒ¼', 'ãƒãƒ§ã‚­', 'ãƒ‘ãƒ¼'],
          datasets: [{
            label: 'ã‚ãªãŸã®æ‰‹ã®å†…è¨³',
            data: [userHistory['ã‚°ãƒ¼'], userHistory['ãƒãƒ§ã‚­'], userHistory['ãƒ‘ãƒ¼']],
            backgroundColor: ['#f87171', '#fbbf24', '#34d399']
          }]
        },
        options: { /* ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯å¤‰æ›´ãªã— */
            responsive: false,
            maintainAspectRatio: false,
            plugins: {
                legend: { labels: { font: { size: 14 } } },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const data = context.dataset.data;
                            const total = data.reduce((s, v) => s + v, 0);
                            const pct = total ? (context.parsed / total * 100).toFixed(1) : '0.0';
                            return `${context.label}: ${pct}% (${context.parsed}å›)`; // å›æ•°ã‚‚è¡¨ç¤º
                        }
                    }
                }
            }
        }
      });
    }

    // --- é–¢æ•°å®šç¾© ---

    /**
     * ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’è¡¨ç¤º
     */
    function debugLog(message) {
        const time = new Date().toLocaleTimeString();
        if (debugInfoEl) {
            debugInfoEl.innerHTML = `[${time}] ${message}<br>` + debugInfoEl.innerHTML;
            const lines = debugInfoEl.innerHTML.split('<br>');
            if (lines.length > 51) { // æœ€å¤§50è¡Œè¡¨ç¤º
                debugInfoEl.innerHTML = lines.slice(0, 50).join('<br>');
            }
        } else {
            console.log(`[DEBUG] ${message}`);
        }
    }


    /**
     * ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–ã¾ãŸã¯ãƒªã‚»ãƒƒãƒˆ
     */
    function initGame() {
        debugLog("ã‚²ãƒ¼ãƒ åˆæœŸåŒ–é–‹å§‹ã•ãƒ¼...");
        // å¤‰æ•°ãƒªã‚»ãƒƒãƒˆ
        committedAiChoice = null;
        userHistory = { 'ã‚°ãƒ¼': 0, 'ãƒãƒ§ã‚­': 0, 'ãƒ‘ãƒ¼': 0 };
        userSequence = [];
        patternMap = {};
        winLossHistory = [];
        userWins = 0; aiWins = 0; draws = 0;
        userStreak = 0; aiStreak = 0; maxUserStreak = 0; maxAiStreak = 0;
        roundsPlayed = 0;
        lastUserDistribution = { 'ã‚°ãƒ¼': 0, 'ãƒãƒ§ã‚­': 0, 'ãƒ‘ãƒ¼': 0 };
        aiReasoning = "ã•ã‚ã€å§‹ã‚ã‚‹ã‚ˆãƒ¼ï¼";
        strategicBluff = "ã‚­ã‚¸ãƒ ãƒ³: ã‚ˆãƒ¼ã—ã€ã˜ã‚ƒã‚“ã‘ã‚“ã™ã‚‹ã•ãƒ¼ï¼";

        // â˜…â˜…â˜… ä¿®æ­£: ãƒ¢ãƒ‡ãƒ«ã‚¿ã‚¤ãƒ—ã§è¨­å®šã‚’å–å¾— â˜…â˜…â˜…
        const modelKey = modelTypeSelect.value;
        const setting = MODEL_SETTINGS[modelKey];
        epsilon = setting.epsilon;
        MODEL_SEQ_LEN = setting.seqLen; // predictUserChoice ã§å‚ç…§ã™ã‚‹å…¥åŠ›é•·
        useOnlineTraining = setting.trainBatch; // ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å­¦ç¿’ãƒ•ãƒ©ã‚°
        usePatterns = setting.usePatterns; // ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºãƒ•ãƒ©ã‚°

        // â˜…â˜…â˜… ä¿®æ­£: currentMaxPattern ã‚’åˆæœŸåŒ– â˜…â˜…â˜…
        currentMaxPattern = gameSettings.initialMaxPattern;

        // NNãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ã†æˆ¦ç•¥ã§ã€ãƒ¢ãƒ‡ãƒ«ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„å ´åˆã¯åˆæœŸåŒ–
        if ((modelKey === 'nn' || modelKey === 'hybrid') && !jankenModel) {
            debugLog("NNãƒ¢ãƒ‡ãƒ«ãŒã¾ã ãªã„ã‹ã‚‰åˆæœŸåŒ–ã™ã‚‹ã•ãƒ¼");
            // initJankenModelã¯éåŒæœŸãªã®ã§å¾…ã¤ (å®Ÿéš›ã«ã¯DOMContentLoadedã§å…ˆã«å‘¼ã°ã‚Œã‚‹æƒ³å®š)
             initJankenModel(); // ã“ã“ã§å‘¼ã¶ã‚ˆã‚ŠDOMContentLoadedã§å‘¼ã¶æ–¹ãŒç¢ºå®Ÿ
        }


        // UIåˆæœŸåŒ–
        initializeCharts(); // ãƒãƒ£ãƒ¼ãƒˆã‚‚ã“ã“ã§åˆæœŸåŒ–
        updateUI('å‹è² ã•ãƒ¼ï¼', '', ''); // åˆæœŸçŠ¶æ…‹ã®UIæ›´æ–°
        faceEl.src = IMG_THINK;
        choiceBtns.forEach(btn => btn.disabled = false);
        // debugInfoEl.innerHTML = "ãƒ‡ãƒãƒƒã‚°æƒ…å ±:"; // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚¯ãƒªã‚¢ (ä»»æ„)
        debugLog(`ã‚²ãƒ¼ãƒ åˆæœŸåŒ–å®Œäº†ã•ãƒ¼ã€‚ãƒ¢ãƒ‡ãƒ«ã‚¿ã‚¤ãƒ—: ${setting.label}`);
    }


    /**
     * ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å±¥æ­´ã¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ›´æ–°
     */
    function updateGameHistory(userChoice) {
        userHistory[userChoice]++;
        userSequence.push(userChoice);
        // userSequenceã®é•·ã•ã‚’åˆ¶é™ï¼ˆä¾‹ï¼šç›´è¿‘50æ‰‹ãªã©ï¼‰
        if (userSequence.length > 50) {
            userSequence.shift();
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ—æ›´æ–° (usePatternsãŒtrueã®å ´åˆã®ã¿)
        if (usePatterns) {
            // ç¾åœ¨ã®æœ€å¤§ãƒ‘ã‚¿ãƒ¼ãƒ³é•·ä»¥ä¸‹ã®é•·ã•ã§ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¨˜éŒ²
            for (let len = 1; len <= Math.min(currentMaxPattern, userSequence.length - 1); len++) {
                // å±¥æ­´ã®æœ«å°¾ã‹ã‚‰len+1å€‹å‰ï½æœ«å°¾ã‹ã‚‰1å€‹å‰ã¾ã§ã‚’ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚­ãƒ¼ã¨ã™ã‚‹
                const patternKey = userSequence.slice(-len - 1, -1).join('_');
                // ãã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ç¶šã„ãŸå®Ÿéš›ã®æ‰‹
                const nextChoice = userSequence[userSequence.length - 1];

                if (!patternMap[patternKey]) {
                    patternMap[patternKey] = { 'ã‚°ãƒ¼': 0, 'ãƒãƒ§ã‚­': 0, 'ãƒ‘ãƒ¼': 0, 'count': 0 };
                }
                patternMap[patternKey][nextChoice]++;
                patternMap[patternKey]['count']++;
            }
        }
        // debugLog(`ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒ—æ›´æ–°: ã‚­ãƒ¼æ•°=${Object.keys(patternMap).length}`);
    }

    /**
     * ãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡ºã®æœ€å¤§é•·ã‚’å‹•çš„ã«èª¿æ•´
     */
    function updateDynamicMaxPattern() {
        // usePatterns ãŒ true ã®å ´åˆã®ã¿ãƒ‘ã‚¿ãƒ¼ãƒ³é•·ã‚’æ›´æ–°
        if (usePatterns) {
            const potentialMaxPattern = Math.floor(gameSettings.initialMaxPattern + roundsPlayed * gameSettings.patternGrowthRate);
            currentMaxPattern = Math.min(potentialMaxPattern, gameSettings.maxPatternCap);
            // debugLog(`å‹•çš„ãƒ‘ã‚¿ãƒ¼ãƒ³é•·æ›´æ–°: ç¾åœ¨=${currentMaxPattern}`);
        } else {
            currentMaxPattern = 1; // ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã‚ãªã„å ´åˆã¯1å›ºå®šï¼ˆã¾ãŸã¯ä»–ã®é©åˆ‡ãªå€¤ï¼‰
        }
    }
        /**
     * â˜…â˜…â˜… æ”¹å–„: ç›¸æ‰‹ã®æˆ¦ç•¥å¤‰åŒ–ã‚’æ¤œå‡ºã—ã€ãƒ‘ã‚¿ãƒ¼ãƒ³å¿˜å´ã‚‚è¡Œã† â˜…â˜…â˜…
     */
     function detectStrategyChange() {
        if (roundsPlayed < 10) return false;

        const currentDistribution = {};
        let total = 0;
        for(const choice of CHOICES) {
            currentDistribution[choice] = userHistory[choice];
            total += userHistory[choice];
        }
        if (total === 0) return false;

        let diffSum = 0;
        // å‰å› (lastUserDistribution) ã®åˆè¨ˆå›æ•°ã‚’å–å¾—
        const lastTotal = lastUserDistribution.total || (roundsPlayed > 0 ? roundsPlayed : 1);

        for(const choice of CHOICES) {
            const currentRate = currentDistribution[choice] / total;
            const lastRate = (lastUserDistribution[choice] || 0) / lastTotal;
            diffSum += Math.abs(currentRate - lastRate);
        }
        const changeMagnitude = diffSum / 2; // æ­£è¦åŒ– (0-1)

        // lastUserDistribution ã‚’æ›´æ–°
        lastUserDistribution = {...currentDistribution};
        lastUserDistribution.total = total; // åˆè¨ˆå›æ•°ã‚‚ä¿æŒ

        // debugLog(`æˆ¦ç•¥å¤‰åŒ–ãƒã‚§ãƒƒã‚¯: å¤‰åŒ–é‡=${changeMagnitude.toFixed(3)} (é–¾å€¤: ${gameSettings.adaptThreshold})`); // ãƒ­ã‚°ã¯ä»»æ„

        if (changeMagnitude > gameSettings.adaptThreshold) {
            debugLog("ãŠã£ã¨ã€æ‰‹ã®å‡ºã—æ–¹ãŒå¤‰ã‚ã£ãŸã•ãƒ¼ï¼Ÿ ã¡ã‚‡ã£ã¨è€ƒãˆç›´ã™ã‚ˆãƒ¼ï¼");
            epsilon = Math.min(1.0, epsilon * 1.5); // æ¢ç´¢ç‡ã‚’ä¸€æ™‚çš„ã«ä¸Šã’ã‚‹

            // â˜…â˜…â˜… ãƒ‘ã‚¿ãƒ¼ãƒ³å¿˜å´å‡¦ç† â˜…â˜…â˜…
            if (usePatterns) {
                debugLog("å¤ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯å¿˜ã‚Œã‚ˆã†ã•ãƒ¼...");
                let forgottenCount = 0;
                for (const key in patternMap) {
                    const patternData = patternMap[key];
                    let newTotalCount = 0;
                    for (const choice of CHOICES) {
                        // å„æ‰‹ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’æŒ‡å®šç‡ã§æ¸›ã‚‰ã™ (å°æ•°ç‚¹ä»¥ä¸‹åˆ‡ã‚Šæ¨ã¦)
                        patternData[choice] = Math.floor(patternData[choice] * gameSettings.patternForgetRate);
                        newTotalCount += patternData[choice];
                    }
                    patternData.count = newTotalCount;
                    // ã‚«ã‚¦ãƒ³ãƒˆãŒ0ã«ãªã£ãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã¯å‰Šé™¤ã—ã¦ã‚‚è‰¯ã„
                    if (patternData.count === 0) {
                        delete patternMap[key];
                        forgottenCount++;
                    }
                }
                 debugLog(`${forgottenCount}å€‹ã®å¤ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å¿˜ã‚ŒãŸ(ã¾ãŸã¯å¼±ã‚ãŸ)ã•ãƒ¼`);
            }
            return true;
        }
        return false;
    }

    /**
     * ç›¸æ‰‹ã®æ‰‹ã®ãƒ©ãƒ³ãƒ€ãƒ æ€§ã‚’è©•ä¾¡ (ã‚¨ãƒ³ãƒˆãƒ­ãƒ”ãƒ¼è¨ˆç®—)
     */
     function assessOpponentRandomness() {
        const total = roundsPlayed;
        if (total < 5) return 0.5; // ãƒ‡ãƒ¼ã‚¿ä¸è¶³æ™‚ã¯ä¸­é–“å€¤

        let entropy = 0;
        for (const choice of CHOICES) {
            const probability = userHistory[choice] / total;
            if (probability > 0) {
                entropy -= probability * Math.log2(probability);
            }
        }
        // æœ€å¤§ã‚¨ãƒ³ãƒˆãƒ­ãƒ”ãƒ¼ (log2(3)) ã§æ­£è¦åŒ–ã—ã¦ 0~1 ã®å€¤ã«ã™ã‚‹
        const normalizedEntropy = entropy / Math.log2(3);
        debugLog(`ç›¸æ‰‹ã®ãƒ©ãƒ³ãƒ€ãƒ æ€§ãƒã‚§ãƒƒã‚¯: ${normalizedEntropy.toFixed(3)} (1ã«è¿‘ã„ã»ã©ãƒ©ãƒ³ãƒ€ãƒ ã•ãƒ¼)`);
        // ãƒ©ãƒ³ãƒ€ãƒ æ€§ãŒé«˜ã„å ´åˆã€Îµã‚’ä¸Šã’ã‚‹ãªã©ã®èª¿æ•´ã‚‚å¯èƒ½
        // if (normalizedEntropy > 0.9) epsilon = Math.min(1.0, epsilon + 0.1);
        return normalizedEntropy;
    }

        // =============================================
    // === äºˆæ¸¬ãƒ­ã‚¸ãƒƒã‚¯ã®æ”¹å–„ (ã“ã“ãŒãƒ¡ã‚¤ãƒ³) ===
    // =============================================

    /**
     * NNãƒ¢ãƒ‡ãƒ«ã«ã‚ˆã‚‹äºˆæ¸¬ (ä¿¡é ¼åº¦ã‚‚è¿”ã™)
     */
     async function predictWithNN() {
        if (!jankenModel || userSequence.length < MODEL_SEQ_LEN) {
            return { predicted: null, confidence: 0, reason: "NNãƒ‡ãƒ¼ã‚¿ä¸è¶³" };
        }
        try {
            const seq = userSequence.slice(-MODEL_SEQ_LEN);
            const inputVec = seq.flatMap(c => CHOICES.map(ch => ch === c ? 1 : 0));
            const inputTensor = tf.tensor2d([inputVec]);
            const output = await jankenModel.predict(inputTensor);
            const probs = await output.data();
            inputTensor.dispose();
            output.dispose();

            const maxIdx = probs.indexOf(Math.max(...probs));
            const predicted = CHOICES[maxIdx];
            const confidence = probs[maxIdx];
            const reason = `NNäºˆæ¸¬(${predicted}, ä¿¡:${(confidence * 100).toFixed(0)}%)`;
            // debugLog(reason); // ãƒ­ã‚°ã¯ä»»æ„
            return { predicted, confidence, reason };
        } catch (error) {
            console.error("NNäºˆæ¸¬ã‚¨ãƒ©ãƒ¼:", error);
            debugLog(`NNäºˆæ¸¬ã‚¨ãƒ©ãƒ¼ã•ãƒ¼: ${error.message}`);
            return { predicted: null, confidence: 0, reason: "NNäºˆæ¸¬ã‚¨ãƒ©ãƒ¼" };
        }
    }

    /**
     * â˜…â˜…â˜… æ”¹å–„: ãƒ‘ã‚¿ãƒ¼ãƒ³ã«åŸºã¥ãäºˆæ¸¬ (ä¿¡é ¼åº¦ã‚‚è¿”ã™) â˜…â˜…â˜…
     */
    function predictWithPatterns() {
        if (!usePatterns || userSequence.length < 1) {
             return { predicted: null, confidence: 0, reason: "ãƒ‘ã‚¿ãƒ¼ãƒ³æœªä½¿ç”¨ã¾ãŸã¯å±¥æ­´ä¸è¶³" };
        }

        let bestPrediction = null;
        let highestConfidence = -1;
        let bestReason = "æœ‰åŠ¹ãƒ‘ã‚¿ãƒ¼ãƒ³ãªã—";

        // æœ€é•·ãƒ‘ã‚¿ãƒ¼ãƒ³ã‹ã‚‰é †ã«è©¦ã™
        for (let len = Math.min(currentMaxPattern, userSequence.length - 1); len >= 1; len--) {
            const patternKey = userSequence.slice(-len - 1, -1).join('_');
            const patternData = patternMap[patternKey];

            if (patternData && patternData.count > 0) { // ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒå­˜åœ¨ã—ã€ã‚«ã‚¦ãƒ³ãƒˆãŒã‚ã‚‹
                let predictedForPattern = null;
                let highestFreq = -1;

                // ãã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§æœ€ã‚‚å¤šãå‡ºã•ã‚ŒãŸæ‰‹ã‚’æ¢ã™
                for (const choice of CHOICES) {
                    if (patternData[choice] > highestFreq) {
                        highestFreq = patternData[choice];
                        predictedForPattern = choice;
                    }
                }

                if (predictedForPattern) {
                    // â˜…â˜…â˜… ä¿¡é ¼åº¦ = ãã®æ‰‹ãŒé¸ã°ã‚ŒãŸå›æ•° / ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒå‡ºç¾ã—ãŸç·å›æ•° â˜…â˜…â˜…
                    const confidence = highestFreq / patternData.count;
                    const reason = `ãƒ‘ã‚¿ãƒ¼ãƒ³(${patternKey}â†’${predictedForPattern}, ä¿¡:${(confidence * 100).toFixed(0)}%, ${patternData.count}å›)`;

                    // ã‚ˆã‚Šé•·ãã€ã‚ˆã‚Šä¿¡é ¼åº¦ã®é«˜ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å„ªå…ˆã™ã‚‹
                    // (å˜ç´”ã«ä¿¡é ¼åº¦ã ã‘ã§æ¯”è¼ƒã—ã¦ã‚‚è‰¯ã„ã—ã€é•·ã•ã‚‚åŠ å‘³ã—ã¦ã‚‚è‰¯ã„)
                    // ã“ã“ã§ã¯ã€é–¾å€¤ã‚’è¶…ãˆã€ã‹ã¤ã“ã‚Œã¾ã§ã§æœ€ã‚‚ä¿¡é ¼åº¦ãŒé«˜ã„ã‚‚ã®ã‚’æ¡ç”¨
                    if (confidence >= gameSettings.patternConfidenceThreshold && confidence > highestConfidence) {
                        highestConfidence = confidence;
                        bestPrediction = predictedForPattern;
                        bestReason = reason;
                        // debugLog(`æœ‰åŠ›ãƒ‘ã‚¿ãƒ¼ãƒ³ç™ºè¦‹: ${reason}`); // ãƒ­ã‚°ã¯ä»»æ„
                        // ååˆ†ä¿¡é ¼ã§ãã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒè¦‹ã¤ã‹ã‚Œã°ã€ãã‚Œä»¥ä¸ŠçŸ­ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯è¦‹ãªã„ã§ã‚‚è‰¯ã„ã‹ã‚‚
                         if (len > 1 && confidence > 0.8) break;
                    }
                }
            }
        }

        if (bestPrediction) {
             // debugLog(`ãƒ‘ã‚¿ãƒ¼ãƒ³äºˆæ¸¬ çµæœ: ${bestReason}`);
             return { predicted: bestPrediction, confidence: highestConfidence, reason: bestReason };
        } else {
             return { predicted: null, confidence: 0, reason: bestReason };
        }
    }

    /**
     * é »åº¦ã«åŸºã¥ãäºˆæ¸¬ (ä¿¡é ¼åº¦ã‚‚è¿”ã™)
     */
    function predictWithFrequency() {
        let mostFrequent = null;
        let maxFreq = -1;
        let totalHands = 0;
        for (const choice of CHOICES) {
            totalHands += userHistory[choice];
            if (userHistory[choice] > maxFreq) {
                maxFreq = userHistory[choice];
                mostFrequent = choice;
            }
        }

        if (mostFrequent && totalHands > 0) {
            const confidence = maxFreq / totalHands; // ä¿¡é ¼åº¦ = æœ€å¤šé »åº¦ã®æ‰‹ã®å‰²åˆ
            const reason = `é »åº¦äºˆæ¸¬(${mostFrequent}, ä¿¡:${(confidence * 100).toFixed(0)}%)`;
             // debugLog(reason); // ãƒ­ã‚°ã¯ä»»æ„
            return { predicted: mostFrequent, confidence, reason };
        } else {
            return { predicted: null, confidence: 0, reason: "é »åº¦ãƒ‡ãƒ¼ã‚¿ä¸è¶³" };
        }
    }


    /**
     * â˜…â˜…â˜… æ”¹å–„: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ¬¡ã®æ‰‹ã‚’äºˆæ¸¬ (ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰æˆ¦ç•¥å¼·åŒ–) â˜…â˜…â˜…
     */
    async function predictUserChoice() {
        const modelKey = modelTypeSelect.value;

        // å„æˆ¦ç•¥ã§äºˆæ¸¬ã‚’å®Ÿè¡Œ
        const nnPrediction = (modelKey === 'nn' || modelKey === 'hybrid') ? await predictWithNN() : { predicted: null, confidence: 0, reason: "NNæœªä½¿ç”¨" };
        const patternPrediction = (modelKey === 'pattern' || modelKey === 'hybrid') ? predictWithPatterns() : { predicted: null, confidence: 0, reason: "ãƒ‘ã‚¿ãƒ¼ãƒ³æœªä½¿ç”¨" };
        const frequencyPrediction = predictWithFrequency(); // é »åº¦ã¯å¸¸ã«è¨ˆç®—ã—ã¦ãŠã (ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨)

        let finalPrediction = { predicted: null, confidence: -1, reason: "äºˆæ¸¬å¤±æ•—" };

        // --- æˆ¦ç•¥ã‚¿ã‚¤ãƒ—ã”ã¨ã®äºˆæ¸¬é¸æŠãƒ­ã‚¸ãƒƒã‚¯ ---

        if (modelKey === 'nn') {
            if (nnPrediction.confidence >= gameSettings.nnConfidenceThreshold) {
                finalPrediction = nnPrediction;
            } else {
                // NNã®ä¿¡é ¼åº¦ãŒä½ã„å ´åˆã¯é »åº¦ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                finalPrediction = frequencyPrediction;
                finalPrediction.reason = `NNä¿¡é ¼åº¦ä½(${nnPrediction.reason}) â†’ ${frequencyPrediction.reason}`;
            }
        }
        else if (modelKey === 'pattern') {
            if (patternPrediction.confidence > 0) { // é–¾å€¤ãƒã‚§ãƒƒã‚¯ã¯ predictWithPatterns å†…ã§è¡Œã†
                finalPrediction = patternPrediction;
            } else {
                // ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯é »åº¦ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                finalPrediction = frequencyPrediction;
                finalPrediction.reason = `æœ‰åŠ¹ãƒ‘ã‚¿ãƒ¼ãƒ³ãªã— â†’ ${frequencyPrediction.reason}`;
            }
        }
        else if (modelKey === 'hybrid') {
            // â˜… ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰: NNã¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ä¿¡é ¼åº¦ã‚’æ¯”è¼ƒ
            let bestConfidence = -1;
            let chosenReason = "ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰: ";

            if (nnPrediction.confidence > bestConfidence && nnPrediction.confidence >= gameSettings.nnConfidenceThreshold) {
                bestConfidence = nnPrediction.confidence;
                finalPrediction = nnPrediction;
                chosenReason += `NNå„ªå…ˆ (${nnPrediction.reason})`;
            }
            if (patternPrediction.confidence > bestConfidence && patternPrediction.confidence >= gameSettings.patternConfidenceThreshold) {
                // NNã‚ˆã‚Šãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ–¹ãŒä¿¡é ¼åº¦ãŒé«˜ã‘ã‚Œã°ä¸Šæ›¸ã
                 if (patternPrediction.confidence > nnPrediction.confidence) {
                     bestConfidence = patternPrediction.confidence;
                     finalPrediction = patternPrediction;
                     chosenReason += `ãƒ‘ã‚¿ãƒ¼ãƒ³å„ªå…ˆ (${patternPrediction.reason})`;
                 } else if (finalPrediction.predicted === null) {
                     // NNã®ä¿¡é ¼åº¦ãŒé–¾å€¤æœªæº€ã§ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒé–¾å€¤ä»¥ä¸Šã®å ´åˆ
                     bestConfidence = patternPrediction.confidence;
                     finalPrediction = patternPrediction;
                     chosenReason += `ãƒ‘ã‚¿ãƒ¼ãƒ³æ¡ç”¨ (${patternPrediction.reason})`;
                 }
            }

            // NNã‚‚ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚‚ä¿¡é ¼åº¦ãŒä½ã„ã€ã¾ãŸã¯äºˆæ¸¬ã§ããªã‹ã£ãŸå ´åˆ
            if (finalPrediction.predicted === null) {
                finalPrediction = frequencyPrediction;
                chosenReason += `NN/ãƒ‘ã‚¿ãƒ¼ãƒ³ä¿¡é ¼åº¦ä½ â†’ ${frequencyPrediction.reason}`;
            }
            finalPrediction.reason = chosenReason; // æœ€çµ‚çš„ãªç†ç”±ã‚’æ›´æ–°

        }
        else { // frequency ã¾ãŸã¯äºˆæœŸã›ã¬ãƒ¢ãƒ‡ãƒ«ã‚­ãƒ¼
            finalPrediction = frequencyPrediction;
        }

        // æœ€çµ‚çš„ã«ã©ã®æˆ¦ç•¥ã§ã‚‚äºˆæ¸¬ã§ããªã‹ã£ãŸå ´åˆ (åˆæœŸçŠ¶æ…‹ãªã©) ã¯ãƒ©ãƒ³ãƒ€ãƒ 
        if (finalPrediction.predicted === null) {
            finalPrediction.predicted = CHOICES[Math.floor(Math.random() * 3)];
            finalPrediction.confidence = 1/3;
            finalPrediction.reason = `å…¨æˆ¦ç•¥å¤±æ•— â†’ ãƒ©ãƒ³ãƒ€ãƒ (${finalPrediction.predicted})`;
        }

        debugLog(`æœ€çµ‚äºˆæ¸¬: ${finalPrediction.predicted} (ç†ç”±: ${finalPrediction.reason})`);
        // chooseAIHand ã«æ¸¡ã™ã®ã¯äºˆæ¸¬ã•ã‚ŒãŸæ‰‹ã¨ã€æœ€çµ‚çš„ãªç†ç”±
        return { predicted: finalPrediction.predicted, reason: finalPrediction.reason, confidence: finalPrediction.confidence };
    }


    // --- chooseAIHand, determineOutcome, updateGameState, generateStrategicBluff, updateUI, checkGameEnd, playRound ã¯åŸºæœ¬çš„ã«å¤‰æ›´ãªã— ---
    // (predictUserChoice ã®è¿”ã‚Šå€¤ãŒå¤‰ã‚ã£ãŸã®ã§ã€chooseAIHand ã®å‘¼ã³å‡ºã—å…ƒ playRound ã§ confidence ã‚’å—ã‘å–ã‚‹å¿…è¦ã¯ãªããªã£ãŸ)
    function chooseAIHand(predictedChoice, predictionReason /*, predictionConfidence ã¯å‰Šé™¤ */) {
        let aiChoice, reason;
        // const adjustedEpsilon = epsilon / (predictionConfidence + 0.1); // ä¿¡é ¼åº¦ã«å¿œã˜ãŸÎµèª¿æ•´ã‚‚å¯èƒ½ã ãŒä»Šå›ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«

        if (Math.random() < epsilon) {
            aiChoice = CHOICES[Math.floor(Math.random() * 3)];
            reason = `Îµ-greedy ãƒ©ãƒ³ãƒ€ãƒ æ¢ç´¢ (Îµ=${epsilon.toFixed(3)}) â†’ ${aiChoice}`; // Îµã®æ¡æ•°èª¿æ•´
        } else {
            aiChoice = COUNTER_MAP[predictedChoice] || CHOICES[Math.floor(Math.random()*3)];
            reason = `${predictionReason} â†’ ãã‚Œã«å‹ã¤ ${aiChoice} ã‚’é¸æŠ`;
        }
        // debugLog(`AIæ‰‹æ±ºå®š: ${aiChoice} (ç†ç”±: ${reason})`); // playRoundå†…ã§aiReasoningã«æ ¼ç´ã™ã‚‹ã®ã§ã“ã“ã§ã¯ä¸è¦ã‹ã‚‚
        return { aiChoice, reason }; // reasonã«ã¯äºˆæ¸¬ã®æ ¹æ‹ ã¨æœ€çµ‚æ±ºå®šç†ç”±ãŒå«ã¾ã‚Œã‚‹
    }

        /**
     * å‹æ•—ã‚’åˆ¤å®š
     */
     function determineOutcome(userChoice, aiChoice) {
        if (userChoice === aiChoice) {
            return 'å¼•ãåˆ†ã‘';
        } else if (COUNTER_MAP[aiChoice] === userChoice) {
            return 'å‹ã¡'; // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å‹ã¡
        } else {
            return 'è² ã‘'; // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è² ã‘ (AIã®å‹ã¡)
        }
    }

    /**
     * ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’æ›´æ–°
     */
    function updateGameState(outcome, userChoice, aiChoice) {
        roundsPlayed++;
        winLossHistory.push([outcome, userChoice, aiChoice]); // [çµæœ, ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ‰‹, AIã®æ‰‹]

        if (outcome === 'å‹ã¡') {
            userWins++;
            userStreak++;
            aiStreak = 0;
            maxUserStreak = Math.max(maxUserStreak, userStreak);
        } else if (outcome === 'è² ã‘') {
            aiWins++;
            aiStreak++;
            userStreak = 0;
            maxAiStreak = Math.max(maxAiStreak, aiStreak);
        } else {
            draws++;
            userStreak = 0;
            aiStreak = 0;
        }

        // Îµ-greedyæ³•ã®æ¢ç´¢ç‡ã‚’æ¸›è¡°ã•ã›ã‚‹
        epsilon = Math.max(gameSettings.minEpsilon, epsilon * gameSettings.epsilonDecay);

        debugLog(`çµæœæ›´æ–°: Round ${roundsPlayed}, çµæœ: ${outcome}, User: ${userChoice}, AI: ${aiChoice}, Îµ: ${epsilon.toFixed(3)}`);

        // --- ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã§ãƒ¢ãƒ‡ãƒ«ã‚’å­¦ç¿’ (useOnlineTraining ãŒ true ã®å ´åˆ) ---
        if (useOnlineTraining && jankenModel && userSequence.length > MODEL_SEQ_LEN) {
            (async () => { // éåŒæœŸå‡¦ç†ã¨ã—ã¦å®Ÿè¡Œ
               try {
                   const inputSeq = userSequence.slice(-MODEL_SEQ_LEN - 1, -1); // æœ€æ–°ã®æ‰‹ã®ç›´å‰ã¾ã§
                   const nextMove = userSequence[userSequence.length - 1]; // æœ€æ–°ã®æ‰‹ (æ­£è§£ãƒ©ãƒ™ãƒ«)

                   const xs = inputSeq.flatMap(c => CHOICES.map(ch => ch === c ? 1 : 0));
                   const ys = CHOICES.map(ch => ch === nextMove ? 1 : 0);

                   // ãƒãƒƒãƒ•ã‚¡ã«è¿½åŠ 
                   trainBuffer.xs.push(xs);
                   trainBuffer.ys.push(ys);

                   // ãƒãƒƒãƒ•ã‚¡ãŒä¸€å®šæ•°è²¯ã¾ã£ãŸã‚‰å­¦ç¿’å®Ÿè¡Œ
                   const BATCH_SIZE = 10; // 10å›åˆ†ã®ãƒ‡ãƒ¼ã‚¿ãŒè²¯ã¾ã£ãŸã‚‰å­¦ç¿’
                   if (trainBuffer.xs.length >= BATCH_SIZE) {
                       debugLog(`NNå­¦ç¿’é–‹å§‹ã•ãƒ¼ (ãƒ‡ãƒ¼ã‚¿ ${BATCH_SIZE}ä»¶)`);
                       const xsTensor = tf.tensor2d(trainBuffer.xs);
                       const ysTensor = tf.tensor2d(trainBuffer.ys);
                       // å­¦ç¿’ (fitã¯éåŒæœŸ)
                       const history = await jankenModel.fit(xsTensor, ysTensor, {
                           epochs: 5, // ã‚¨ãƒãƒƒã‚¯æ•° (é©å®œèª¿æ•´)
                           batchSize: BATCH_SIZE, // ãƒãƒƒãƒã‚µã‚¤ã‚º
                           // validationSplit: 0.1 // æ¤œè¨¼ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ã†å ´åˆ
                       });
                       xsTensor.dispose();
                       ysTensor.dispose();
                       // ãƒãƒƒãƒ•ã‚¡ã‚’ã‚¯ãƒªã‚¢
                       trainBuffer.xs = [];
                       trainBuffer.ys = [];
                       debugLog(`NNå­¦ç¿’å®Œäº†ã•ãƒ¼ (Loss: ${history.history.loss[history.history.loss.length - 1].toFixed(4)})`);
                   }
               } catch (error) {
                   console.error("NNã‚ªãƒ³ãƒ©ã‚¤ãƒ³å­¦ç¿’ã‚¨ãƒ©ãƒ¼:", error);
                   debugLog(`NNã‚ªãƒ³ãƒ©ã‚¤ãƒ³å­¦ç¿’ã‚¨ãƒ©ãƒ¼ã•ãƒ¼: ${error.message}`);
                   // å­¦ç¿’ã‚¨ãƒ©ãƒ¼ãŒé »ç™ºã™ã‚‹å ´åˆã€useOnlineTrainingã‚’falseã«ã™ã‚‹ãªã©ã®å¯¾ç­–ã‚‚
                   // useOnlineTraining = false;
               }
            })(); // éåŒæœŸé–¢æ•°ã‚’å®Ÿè¡Œ
        }
    }

    /**
     * æˆ¦ç•¥çš„ãªãƒ–ãƒ©ãƒ•ã‚’ç”Ÿæˆ (ã‚­ã‚¸ãƒ ãƒ³é¢¨)
     */
    function generateStrategicBluff(predictedChoice, lastAiChoice, lastUserChoice, lastOutcome) {
        const bluffs = [];
        bluffs.push(`ã‚­ã‚¸ãƒ ãƒ³: æ¬¡ã¯ãŠã„ã‚‰ã€${CHOICES[Math.floor(Math.random() * 3)]}ã‚’ã ã™ã‚ˆï½ï¼`); // ãƒ©ãƒ³ãƒ€ãƒ ãªå®£è¨€

        if(predictedChoice){
            bluffs.push(`ã‚­ã‚¸ãƒ ãƒ³: ãµã‚€ãµã‚€ã€æ¬¡ã¯${predictedChoice}ã§æ¥ã‚‹ã¯ãšã•ãƒ¼ï¼`);
            bluffs.push(`ã‚­ã‚¸ãƒ ãƒ³: ${predictedChoice}ã«ã¯ã€${COUNTER_MAP[predictedChoice]}ã•ãƒ¼ï¼ã“ã‚Œã©ã†ï¼Ÿ`); // ç›¸æ‰‹ã®æ‰‹ã«å‹ã¤æ‰‹ã‚’å®£è¨€
        }
        if(lastOutcome === 'è² ã‘' && lastUserChoice){ // AIãŒè² ã‘ãŸå ´åˆ
            bluffs.push(`ã‚­ã‚¸ãƒ ãƒ³: ã†ããã€ã•ã£ãã®${lastUserChoice}ã¯å¼·ã‹ã£ãŸã•ãƒ¼ï¼`);
            bluffs.push(`ã‚­ã‚¸ãƒ ãƒ³: åŒã˜æ‰‹(${lastUserChoice})ã«ã¯ã‚‚ã†å¼•ã£ã‹ã‹ã‚‰ãªã„ã‚ˆãƒ¼ï¼`);
        }
        if(lastOutcome === 'å‹ã¡' && lastAiChoice){ // AIãŒå‹ã£ãŸå ´åˆ
            bluffs.push(`ã‚­ã‚¸ãƒ ãƒ³: ${lastAiChoice}ãŒæ±ºã¾ã£ãŸã­ãƒ¼ï¼ã‚‚ã†ä¸€å›ã„ãã•ãƒ¼ï¼Ÿ`);
        }
        if(aiStreak >= 2){
            bluffs.push(`ã‚­ã‚¸ãƒ ãƒ³: ${aiStreak}é€£å‹ã•ãƒ¼ï¼ ãŠã„ã‚‰çµ¶å¥½èª¿ã ã‚ˆãƒ¼ï¼`);
        }
        if(userStreak >= 2){
            bluffs.push(`ã‚­ã‚¸ãƒ ãƒ³: ${userStreak}é€£å‹ã¨ã¯ã‚„ã‚‹ã­ãƒ¼ï¼ã§ã‚‚ã€æ¬¡ã¯ãŠã„ã‚‰ãŒå‹ã¤ã•ãƒ¼ï¼`);
        }
        // æœ€è¿‘ã‚ˆãå‡ºã™æ‰‹ã«ã¤ã„ã¦è¨€åŠ
        const userHandCounts = Object.entries(userHistory).sort(([,a],[,b]) => b-a);
        if (roundsPlayed > 5 && userHandCounts[0][1] > roundsPlayed * 0.5) {
            bluffs.push(`ã‚­ã‚¸ãƒ ãƒ³: ${userHandCounts[0][0]}ã°ã£ã‹ã‚Šå‡ºã™ã­ãƒ¼ï¼èª­ã‚ã¦ããŸã•ãƒ¼ï¼`);
        }


        strategicBluff = bluffs[Math.floor(Math.random() * bluffs.length)];
        // debugLog(`ãƒ–ãƒ©ãƒ•ç”Ÿæˆ: ${strategicBluff}`);
    }


    /**
     * UIã‚’æ›´æ–°ã™ã‚‹
     */
    function updateUI(outcome, userChoice, aiChoice) {
        let imgSrc = IMG_THINK; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯è€ƒãˆä¸­
        let statusColor = '#333'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ©ãƒ¼
        let outcomeText = outcome; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ†ã‚­ã‚¹ãƒˆ

        if (outcome === 'å‹ã¡') { // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å‹ã¡
            imgSrc = IMG_SAD; statusColor = '#ef4444'; outcomeText = "ã‚ãªãŸã®å‹ã¡ï¼";
        } else if (outcome === 'è² ã‘') { // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è² ã‘
            imgSrc = IMG_HAPPY; statusColor = '#3b82f6'; outcomeText = "ã‚­ã‚¸ãƒ ãƒ³ã®å‹ã¡ï¼";
        } else if (outcome === 'å¼•ãåˆ†ã‘') {
            imgSrc = IMG_THINK; statusColor = '#6b7280'; outcomeText = "ã‚ã„ã“ï¼ã‚‚ã†ä¸€å›ï¼";
        }
        // ã‚²ãƒ¼ãƒ çµ‚äº†æ™‚ã¯ checkGameEnd ã§ä¸Šæ›¸ãã•ã‚Œã‚‹

        faceEl.src = imgSrc;
        statusTextEl.textContent = outcomeText;
        statusTextEl.style.color = statusColor;


        // æ‰‹ã®è¡¨ç¤º
        if (userChoice && aiChoice) {
            resultEl.textContent = `ã‚ãªãŸ: ${userChoice} vs ã‚­ã‚¸ãƒ ãƒ³: ${aiChoice}`;
            userHandEl.src = USER_HAND_IMAGES[userChoice] || '';
            aiHandEl.src   = AI_HAND_IMAGES[aiChoice]   || '';
        } else {
            resultEl.textContent = `ã‚ãªãŸ vs ã‚­ã‚¸ãƒ ãƒ³`;
            userHandEl.src = '';
            aiHandEl.src   = '';
        }

        // å±¥æ­´ã¨çµ±è¨ˆæƒ…å ±
        historyEl.textContent = `å±¥æ­´: å‹ã¡(${userWins}), è² ã‘(${aiWins}), ã‚ã„ã“(${draws}) / ${roundsPlayed}å›æˆ¦`;

        const totalGames = userWins + aiWins + draws;
        const userRate = totalGames > 0 ? (userWins / totalGames * 100).toFixed(1) : '0.0';
        const aiRate = totalGames > 0 ? (aiWins / totalGames * 100).toFixed(1) : '0.0';
        statsInfoEl.innerHTML =
          `å‹ç‡: ã‚ãªãŸ ${userRate}% / ã‚­ã‚¸ãƒ ãƒ³ ${aiRate}%<br>` +
          `æœ€å¤§é€£å‹: ã‚ãªãŸ ${maxUserStreak} å›, ã‚­ã‚¸ãƒ ãƒ³ ${maxAiStreak} å›<br>` +
          `ç¾åœ¨ã®ãƒ‘ã‚¿ãƒ¼ãƒ³é•·: ${currentMaxPattern} (Îµ: ${epsilon.toFixed(3)})`; // Îµã‚‚è¡¨ç¤º

        // ã‚°ãƒ©ãƒ•æ›´æ–° (ãƒãƒ£ãƒ¼ãƒˆãŒåˆæœŸåŒ–æ¸ˆã¿ã‹ç¢ºèª)
        if (statsChart && userHistChart) {
            statsChart.data.datasets[0].data = [userWins, aiWins, draws];
            // Yè»¸ã®æœ€å¤§å€¤ã‚’å‹•çš„ã«æ›´æ–°
            statsChart.options.scales.y.suggestedMax = Math.max(userWins, aiWins, draws) + 5;
            statsChart.update();

            userHistChart.data.datasets[0].data = [userHistory['ã‚°ãƒ¼'], userHistory['ãƒãƒ§ã‚­'], userHistory['ãƒ‘ãƒ¼']];
            userHistChart.update();
        }

        // AIæ€è€ƒè¡¨ç¤º
        aiReasoningEl.textContent = aiReasoning; // playRoundã§è¨­å®šã•ã‚ŒãŸæ€è€ƒã‚’è¡¨ç¤º
        aiReasoningEl.style.visibility = showReasoningCheckbox.checked ? 'visible' : 'hidden';
        aiReasoningEl.style.opacity = showReasoningCheckbox.checked ? '1' : '0';

        // ãƒ–ãƒ©ãƒ•è¡¨ç¤º
        bluffEl.textContent = strategicBluff; // generateStrategicBluffã§è¨­å®šã•ã‚ŒãŸãƒ–ãƒ©ãƒ•ã‚’è¡¨ç¤º
    }

    /**
     * ã‚²ãƒ¼ãƒ çµ‚äº†ã‹ãƒã‚§ãƒƒã‚¯
     */
     function checkGameEnd() {
         if (userWins >= WIN_TARGET || aiWins >= WIN_TARGET) {
             choiceBtns.forEach(btn => btn.disabled = true); // ãƒœã‚¿ãƒ³ç„¡åŠ¹åŒ–
             const winner = userWins >= WIN_TARGET ? 'ã‚ãªãŸ' : 'ã‚­ã‚¸ãƒ ãƒ³';
             const finalImg = winner === 'ã‚ãªãŸ' ? IMG_FINAL_USER : IMG_FINAL_AI;
             const finalColor = winner === 'ã‚ãªãŸ' ? '#ef4444' : '#3b82f6';
             const finalBluff = winner === 'ã‚ãªãŸ'
                 ? "ã‚­ã‚¸ãƒ ãƒ³: ã‚ãƒ¼ï¼è² ã‘ã¡ã‚ƒã£ãŸã•ãƒ¼ï¼ã™ã”ã„ã­ãƒ¼ï¼"
                 : "ã‚­ã‚¸ãƒ ãƒ³: ã‚„ã£ãŸãƒ¼ï¼ãŠã„ã‚‰ã®å‹ã¡ã•ãƒ¼ï¼";

             statusTextEl.innerHTML = `å‹è² ã‚ã‚Šï¼<br>${winner}ã®å‹ã¡ã•ãƒ¼ï¼`;
             statusTextEl.style.color = finalColor;
             faceEl.src = finalImg;
             bluffEl.textContent = finalBluff;
             aiReasoning = "ã‚²ãƒ¼ãƒ çµ‚ã‚ã‚Šã•ãƒ¼ï¼";
             aiReasoningEl.textContent = aiReasoning; // æœ€å¾Œã®æ€è€ƒã‚’è¡¨ç¤º
             // æ€è€ƒè¡¨ç¤ºã‚’å¼·åˆ¶çš„ã«ONã«ã™ã‚‹ãªã©ã—ã¦ã‚‚è‰¯ã„ã‹ã‚‚
             // aiReasoningEl.style.visibility = 'visible';
             // aiReasoningEl.style.opacity = '1';

             debugLog(`ã‚²ãƒ¼ãƒ çµ‚äº†ã•ãƒ¼ã€‚å‹è€…: ${winner}`);
             return true; // ã‚²ãƒ¼ãƒ çµ‚äº†
         }
         return false; // ã‚²ãƒ¼ãƒ ç¶šè¡Œ
     }
    /**
     * 1ãƒ©ã‚¦ãƒ³ãƒ‰å®Ÿè¡Œ (predictUserChoice ã®å‘¼ã³å‡ºã—éƒ¨åˆ†å¤‰æ›´)
     */
     async function playRound(userChoice) {
        if (checkGameEnd()) return;

        debugLog(`--- Round ${roundsPlayed + 1} é–‹å§‹ã•ãƒ¼ ---`);
        debugLog(`ã‚ãªãŸã®æ‰‹: ${userChoice}`);
        choiceBtns.forEach(btn => btn.disabled = true);

        updateGameHistory(userChoice);
        detectStrategyChange(); // â˜… ãƒ‘ã‚¿ãƒ¼ãƒ³å¿˜å´å‡¦ç†ã‚’å«ã‚€å¯èƒ½æ€§ã‚ã‚Š
        assessOpponentRandomness();
        updateDynamicMaxPattern();

        // â˜… äºˆæ¸¬å®Ÿè¡Œ (è¿”ã‚Šå€¤ã« confidence ã‚‚å«ã‚€ãŒã€chooseAIHand ã§ã¯ç›´æ¥ä½¿ã‚ãªã„)
        const prediction = await predictUserChoice();

        // â˜… AIã®æ‰‹ã‚’æ±ºå®š (äºˆæ¸¬çµæœã¨ç†ç”±ã‚’æ¸¡ã™)
        const aiDecision = chooseAIHand(prediction.predicted, prediction.reason);
        const currentAiChoice = aiDecision.aiChoice;
        aiReasoning = aiDecision.reason; // â˜… AIã®æ€è€ƒç†ç”±ã‚’æ ¼ç´

        const outcome = determineOutcome(userChoice, currentAiChoice);
        updateGameState(outcome, userChoice, currentAiChoice); // â˜… ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å­¦ç¿’ã‚‚ã“ã“
        updateUI(outcome, userChoice, currentAiChoice); // â˜… UIæ›´æ–°

        if (!checkGameEnd()) {
            // æ¬¡ã®ãƒ–ãƒ©ãƒ•ç”Ÿæˆ (æ¬¡ã®äºˆæ¸¬ã¯ generateStrategicBluff å†…ã§è¡Œã†å¿…è¦ãŒã‚ã‚Œã°è¡Œã†)
             const lastOutcome = outcome;
             const lastUserChoice = userChoice;
             const lastAiChoice = currentAiChoice;
             // generateStrategicBluff ã«æ¸¡ã™ predictedChoice ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã€‚ãªãã¦ã‚‚å‹•ä½œã™ã‚‹ã€‚
             // å¿…è¦ãªã‚‰å†åº¦ predictUserChoice ã‚’å‘¼ã¶
             // const nextPredictionForBluff = await predictUserChoice();
             generateStrategicBluff(prediction.predicted, lastAiChoice, lastUserChoice, lastOutcome);
             bluffEl.textContent = strategicBluff;

            choiceBtns.forEach(btn => btn.disabled = false);
        }

        debugLog(`--- Round ${roundsPlayed} çµ‚äº†ã•ãƒ¼ ---`);
    }

    // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
    choiceBtns.forEach(btn => {
        btn.addEventListener('click', async () => {
            // playRound ã¯éåŒæœŸãªã®ã§ await ã™ã‚‹
            await playRound(btn.dataset.choice);
        });
      });

    modelTypeSelect.addEventListener('change', initGame); // ãƒ¢ãƒ‡ãƒ«ã‚¿ã‚¤ãƒ—å¤‰æ›´æ™‚ã«ã‚²ãƒ¼ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆ

    showReasoningCheckbox.addEventListener('change', ()=>{
        // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®çŠ¶æ…‹ãŒå¤‰ã‚ã£ãŸã‚‰å³åº§ã«æ€è€ƒã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ
        aiReasoningEl.style.visibility = showReasoningCheckbox.checked ? 'visible' : 'hidden';
        aiReasoningEl.style.opacity = showReasoningCheckbox.checked ? '1' : '0';
    });


    // --- ã‚²ãƒ¼ãƒ é–‹å§‹ ---
    document.addEventListener('DOMContentLoaded', async (event) => {
        debugLog("DOMèª­ã¿è¾¼ã¿å®Œäº†ã•ãƒ¼ã€‚");
        // â˜…ä¿®æ­£: NNãƒ¢ãƒ‡ãƒ«ã®åˆæœŸåŒ–ã‚’å¾…ã¤
        await initJankenModel(); // NNãƒ¢ãƒ‡ãƒ«ã‚’åˆæœŸåŒ– (éåŒæœŸ)
        initGame(); // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’åˆæœŸåŒ–
    });

  </script>
</body>
</html>
